---
phase: 03-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/common/mod.rs
  - forge_core/src/types.rs
autonomous: true

must_haves:
  truths:
    - "All core types have comprehensive test coverage (SymbolId, BlockId, PathId, Location, Span, SymbolKind, Language, PathKind, ReferenceKind)"
    - "Type methods (Display, From, predicates) are tested"
    - "Data structure serialization/deserialization works correctly"
    - "Span operations (merge, contains, is_empty, len) are covered"
    - "Common test utilities are available for other tests"
  artifacts:
    - path: "tests/common/mod.rs"
      provides: "Shared test utilities and fixture builders"
      exports: ["test_symbol", "test_location", "test_span", "assert_error_variant", "wait_for"]
      covered_by: "Task 1"
    - path: "forge_core/src/types.rs"
      provides: "Core type definitions with comprehensive test coverage"
      exports: ["test_symbol_id", "test_block_id", "test_path_id", "test_location", "test_span", "test_symbol_kind", "test_language", "test_reference_kind", "test_path_kind", "test_symbol_data_struct", "test_reference_data_struct"]
      covered_by: "Task 2"
  key_links:
    - from: "forge_core/src/types.rs"
      to: "tests/common/mod.rs"
      via: "use statements in test modules"
      pattern: "use tests_common::"

---

<objective>
Create comprehensive test coverage for core types (types.rs) and expand common test utilities.

This plan establishes the testing foundation for ForgeKit by:
1. Adding comprehensive tests for all core types (SymbolId, BlockId, PathId, Location, Span, enums, data structs)
2. Expanding common test utilities with fixture builders and assertion helpers

Purpose: Core types are the foundation used across all modules. They must be thoroughly tested to prevent type-related bugs in higher-level code.

Output: 20-25 new tests for types.rs, expanded test utilities in common/mod.rs
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-runtime-layer/03-RESEARCH.md
@tests/common/mod.rs
@forge_core/src/types.rs
@forge_core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand Common Test Utilities</name>
  <files>tests/common/mod.rs</files>
  <action>
Add the following test utilities to tests/common/mod.rs:

1. **test_symbol()** - Creates a Symbol with test values:
   - id: SymbolId(1)
   - name: "test_function"
   - fully_qualified_name: "my_crate::test_function"
   - kind: SymbolKind::Function
   - language: Language::Rust
   - location: call test_location()
   - parent_id: None
   - metadata: serde_json::Value::Null

2. **test_location()** - Creates a Location with test values:
   - file_path: PathBuf::from("src/test.rs")
   - byte_start: 42
   - byte_end: 84
   - line_number: 7

3. **test_span()** - Creates a Span with test values:
   - start: 10
   - end: 50

4. **assert_error_variant(result, expected)** - Assert helper that verifies a Result is Err and contains expected substring:
   ```rust
   pub fn assert_error_variant<T>(result: anyhow::Result<T>, expected: &str) {
       match result {
           Err(e) => {
               let error_string = e.to_string();
               assert!(error_string.contains(expected),
                   "Expected error containing '{}', got: {}", expected, error_string);
           }
           Ok(_) => panic!("Expected error, got Ok"),
       }
   }
   ```

5. **wait_for(condition, timeout_ms)** - Async helper for polling conditions:
   ```rust
   pub async fn wait_for<F>(mut condition: F, timeout_ms: u64) -> anyhow::Result<()>
   where
       F: FnMut() -> bool,
   {
       use std::time::Instant;
       let start = Instant::now();
       while !condition() {
           if start.elapsed().as_millis() > timeout_ms as u128 {
               anyhow::bail!("Timeout waiting for condition");
           }
           tokio::time::sleep(Duration::from_millis(10)).await;
       }
       Ok(())
   }
   ```

Add #[cfg(test)] module tests for these new utilities.
  </action>
  <verify>
Run: cargo test -p forge_core common
Expected: All new utility tests pass, existing tests still pass
  </verify>
  <done>
tests/common/mod.rs exports: test_forge, create_test_file, create_test_rust_project, test_symbol, test_location, test_span, assert_error_variant, wait_for. All new functions have passing tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Comprehensive Tests for types.rs</name>
  <files>forge_core/src/types.rs</files>
  <action>
Add a #[cfg(test)] mod tests block to forge_core/src/types.rs with the following test functions:

**SymbolId Tests (3 tests):**
1. test_symbol_id_display - Verifies Display format shows integer value
2. test_symbol_id_from_i64 - Verifies From<i64> conversion works
3. test_symbol_id_ord - Verifies ordering comparison works

**BlockId Tests (2 tests):**
1. test_block_id_display - Verifies Display format
2. test_block_id_from_i64 - Verifies From<i64> conversion

**PathId Tests (3 tests):**
1. test_path_id_display - Verifies hex format with colons (e.g., "01:02:ab...")
2. test_path_id_hash_stability - Same input bytes produce same ID
3. test_path_id_hash_uniqueness - Different input bytes produce different IDs

**Location Tests (4 tests):**
1. test_location_span - Verifies span() returns correct Span
2. test_location_len - Verifies len() returns byte_end - byte_start
3. test_location_new - Creates Location with all fields
4. test_location_clnone - Verify Location derives Clone correctly

**Span Tests (5 tests):**
1. test_span_len - Verifies len() returns end - start
2. test_span_is_empty_true - Zero-length span returns true
3. test_span_is_empty_false - Non-zero span returns false
4. test_span_contains - Verifies contains(offset) works for edge cases
5. test_span_merge - Verifies merge() returns min/max correctly

**SymbolKind Tests (2 tests):**
1. test_symbol_kind_is_type - Verifies Struct/Enum/Trait/TypeAlias return true
2. test_symbol_kind_is_function - Verifies Function/Method return true

**Language Tests (2 tests):**
1. test_language_variants - All variants can be constructed
2. test_language_unknown - Unknown variant holds string value

**PathKind Tests (1 test):**
1. test_path_kind_variants - All four variants can be constructed

**ReferenceKind Tests (1 test):**
1. test_reference_kind_variants - All eight variants can be constructed

**Data Structure Tests (2 tests):**
1. test_symbol_new - Symbol can be constructed with all fields
2. test_reference_new - Reference can be constructed with all fields

Use tokio::test for async tests, plain #[test] for sync tests.
  </action>
  <verify>
Run: cargo test -p forge_core types
Expected: ~25 new tests pass, all assertions for type behavior pass
  </verify>
  <done>
forge_core/src/types.rs has #[cfg(test)] mod tests with 25+ test functions covering: ID types (Display, From, Ord), Location/Span methods, enum variants, and data structure construction. All tests pass.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- [ ] cargo test --workspace passes (all existing + new tests)
- [ ] types.rs test coverage > 80%
- [ ] Common utilities are documented with examples
- [ ] No new warnings introduced
</verification>

<success_criteria>
Phase 03-01 complete when:
1. All type tests in types.rs pass (25+ tests)
2. Common test utilities expanded with 5 new helpers
3. cargo test -p forge_core shows 100+ passing tests (up from ~82)
4. No clippy warnings in test code
</success_criteria>

<output>
After completion, create `.planning/phases/03-test-infrastructure/03-01-SUMMARY.md` with:
- List of tests added
- Any issues encountered
- Test coverage metrics if available
</output>
