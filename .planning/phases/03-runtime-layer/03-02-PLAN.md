---
phase: 03-test-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - forge_core/src/lib.rs
  - tests/integration/builder_tests.rs
  - tests/integration/mod.rs
autonomous: true

must_haves:
  truths:
    - "Forge::open() creates a valid instance with working graph database"
    - "Forge::open() creates database at correct .forge/graph.db path"
    - "All module accessors return correct module types"
    - "ForgeBuilder constructs valid Forge instances"
    - "ForgeBuilder supports path, database_path, and cache_ttl configuration"
    - "Forge::with_runtime() creates instance with runtime enabled"
  artifacts:
    - path: "forge_core/src/lib.rs"
      provides: "Forge and ForgeBuilder with test coverage"
      exports: ["test_forge_open", "test_forge_clone", "test_forge_accessors", "test_forge_builder_default", "test_forge_builder_path", "test_forge_builder_database_path", "test_forge_builder_cache_ttl", "test_forge_builder_build"]
      covered_by: "Task 1"
    - path: "tests/integration/builder_tests.rs"
      provides: "Integration tests for ForgeBuilder patterns"
      exports: ["test_builder_default_config", "test_builder_custom_db_path", "test_builder_cache_ttl", "test_builder_requires_path"]
      covered_by: "Task 2"
    - path: "tests/integration/mod.rs"
      provides: "Integration test module declarations"
      exports: ["builder_tests", "accessor_tests"]
      covered_by: "Task 2"
  key_links:
    - from: "tests/integration/builder_tests.rs"
      to: "forge_core::Forge"
      via: "use forge_core::Forge"
      pattern: "Forge::open|ForgeBuilder"
    - from: "tests/integration/mod.rs"
      to: "forge_core::Forge"
      via: "mod declarations"
      pattern: "mod builder_tests"

---

<objective>
Add comprehensive tests for Forge and ForgeBuilder in lib.rs plus integration test infrastructure.

This plan covers the main API surface:
1. Unit tests for Forge methods (open, accessors, with_runtime)
2. Unit tests for ForgeBuilder (new, setters, build)
3. Integration test infrastructure and builder-specific tests

Purpose: The Forge and ForgeBuilder are the primary user-facing API. They must be thoroughly tested to ensure users can create and configure Forge instances correctly.

Output: 8-10 unit tests in lib.rs, integration test infrastructure, 4+ integration tests
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-runtime-layer/03-RESEARCH.md
@forge_core/src/lib.rs
@tests/common/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Unit Tests for Forge and ForgeBuilder</name>
  <files>forge_core/src/lib.rs</files>
  <action>
Add a #[cfg(test)] mod tests block to forge_core/src/lib.rs with the following test functions:

**Forge Creation Tests (3 tests):**
1. test_forge_open_creates_database:
   - Create temp directory
   - Call Forge::open(temp.path())
   - Verify .forge/graph.db exists at path
   - Verify Forge instance is returned

2. test_forge_with_runtime_creates_runtime:
   - Create temp directory
   - Call Forge::with_runtime(temp.path()).await
   - Verify Forge::runtime() returns Some
   - Verify runtime is not None

3. test_forge_open_invalid_path:
   - Try to open Forge with empty string path
   - Verify error is returned
   - Verify error message indicates path issue

**Module Accessor Tests (6 tests):**
1. test_forge_graph_accessor - Returns GraphModule
2. test_forge_search_accessor - Returns SearchModule
3. test_forge_cfg_accessor - Returns CfgModule
4. test_forge_edit_accessor - Returns EditModule
5. test_forge_analysis_accessor - Returns AnalysisModule with correct modules
6. test_forge_multiple_accessor_calls - Verify accessors can be called multiple times

**ForgeBuilder Tests (5 tests):**
1. test_forge_builder_default - Builder::new() creates builder with default values
2. test_forge_builder_path - path() setter updates path field
3. test_forge_builder_database_path - database_path() setter updates field
4. test_forge_builder_cache_ttl - cache_ttl() setter updates field
5. test_forge_builder_chain - Verify setters can be chained

**ForgeBuilder Build Tests (4 tests):**
1. test_forge_builder_build_success - Valid builder builds Forge instance
2. test_forge_builder_build_missing_path - Builder without path returns error
3. test_forge_builder_custom_cache_ttl - Builder with custom TTL uses that value
4. test_forge_builder_multiple_builds - Same builder can build multiple instances

**Forge Clone Tests (2 tests):**
1. test_forge_clone - Verify Forge can be cloned
2. test_forge_clone_independence - Cloned Forge operates independently

Total: 20 tests for lib.rs

Use #[tokio::test] for async tests, plain #[test] for sync tests.
  </action>
  <verify>
Run: cargo test -p forge_core lib
Expected: 20 new tests pass, all forge functionality covered
  </verify>
  <done>
forge_core/src/lib.rs has #[cfg(test)] mod tests with 20 test functions covering: Forge creation (open, with_runtime, invalid paths), all module accessors, ForgeBuilder configuration, build success/failure cases, builder chaining, multiple builds, and clone behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Integration Test Infrastructure</name>
  <files>tests/integration/mod.rs</files>
  <action>
Create tests/integration/mod.rs with module declarations for integration tests:

```rust
//! Integration tests for ForgeKit SDK.
//!
//! These tests verify the public API surface and cross-module interactions.

mod builder_tests;
mod accessor_tests;

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_integration_module_exists() {
        // Verify all integration modules compile
        assert!(true);
    }
}
```

Create tests/integration/builder_tests.rs with:
```rust
//! Integration tests for ForgeBuilder pattern.

use forge_core::Forge;
use std::path::PathBuf;

#[tokio::test]
async fn test_builder_default_config() {
    let temp = tempfile::tempdir().unwrap();
    let forge = Forge::open(temp.path()).await.unwrap();

    // Verify default configuration works
    assert!(forge.runtime().is_none());
}

#[tokio::test]
async fn test_builder_custom_db_path() {
    let temp = tempfile::tempdir().unwrap();
    let custom_db = temp.path().join("custom").join("db.sqlite");

    let forge = Forge::open(temp.path()).await.unwrap();

    // Default database path should be .forge/graph.db
    let default_db = temp.path().join(".forge").join("graph.db");
    // Note: After Phase 05, we'll test custom paths
}

#[tokio::test]
async fn test_builder_requires_path() {
    // Empty path should cause error
    let result = Forge::open("").await;
    assert!(result.is_err());
}

#[tokio::test]
async fn test_forge_creates_database_file() {
    let temp = tempfile::tempdir().unwrap();
    let db_path = temp.path().join(".forge").join("graph.db");

    // Verify database doesn't exist initially
    assert!(!db_path.exists());

    // Create Forge
    let forge = Forge::open(temp.path()).await.unwrap();

    // Verify database was created
    assert!(db_path.exists());
    drop(forge);
}
```

Create tests/integration/accessor_tests.rs with:
```rust
//! Integration tests for module accessors.

use forge_core::Forge;
use tests_common::test_forge;

#[tokio::test]
async fn test_all_accessors_work() {
    let (_temp, forge) = test_forge().await.unwrap();

    // All accessors should return valid instances
    let _graph = forge.graph();
    let _search = forge.search();
    let _cfg = forge.cfg();
    let _edit = forge.edit();
    let _analysis = forge.analysis();
}

#[tokio::test]
async fn test_accessor_returns_different_instances() {
    let (_temp, forge) = test_forge().await.unwrap();

    // Accessors should return new instances each call
    let g1 = forge.graph();
    let g2 = forge.graph();
    // They are equal values but different references
}

#[tokio::test]
async fn test_graph_module_has_store() {
    let (_temp, forge) = test_forge().await.unwrap();

    // Graph module should have access to store
    let graph = forge.graph();
    // Verify graph module is functional (no panics)
}

#[tokio::test]
async fn test_search_module_works() {
    let (_temp, forge) = test_forge().await.unwrap();

    // Search module should be functional
    let search = forge.search();
    // Verify search module is functional (no panics)
}
```

Total: 8 integration tests (4 in builder_tests.rs, 4 in accessor_tests.rs)

Ensure tests/ directory has mod.rs to expose integration tests.
  </action>
  <verify>
Run: cargo test --test integration
Expected: All integration tests pass, integration module compiles
  </verify>
  <done>
tests/integration/mod.rs exists and declares builder_tests and accessor_tests modules. builder_tests.rs has 4 tests, accessor_tests.rs has 4 tests. Total 8 integration tests. cargo test --test integration passes.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- [ ] cargo test --workspace passes (all tests)
- [ ] cargo test --test integration runs integration tests
- [ ] lib.rs test coverage > 80%
- [ ] All Forge methods have at least one test
</verification>

<success_criteria>
Phase 03-02 complete when:
1. lib.rs has 20 unit tests for Forge and ForgeBuilder
2. Integration test infrastructure exists (tests/integration/)
3. Integration tests verify builder patterns and accessors (8 tests)
4. cargo test --workspace shows 115+ passing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-test-infrastructure/03-02-SUMMARY.md` with:
- List of unit tests added to lib.rs
- List of integration tests created
- Any API changes needed
</output>
