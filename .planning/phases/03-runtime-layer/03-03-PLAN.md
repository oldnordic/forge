---
phase: 03-test-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - forge_core/src/watcher.rs
  - forge_core/src/indexing.rs
  - forge_core/src/cache.rs
  - forge_core/src/pool.rs
  - forge_core/src/runtime.rs
  - tests/integration/runtime_tests.rs
autonomous: true

must_haves:
  truths:
    - "File watcher detects file system events (create, modify, delete)"
    - "Incremental indexer tracks pending changes and flushes correctly"
    - "Query cache handles TTL expiration and FIFO eviction"
    - "Connection pool enforces max connections limit"
    - "Runtime orchestrates all components together"
    - "Runtime integration with file watching works end-to-end"
  artifacts:
    - path: "forge_core/src/watcher.rs"
      provides: "File watching with comprehensive test coverage"
      exports: ["test_watcher_file_operations", "test_watcher_debounce", "test_watcher_recursive"]
      covered_by: "Task 1"
    - path: "forge_core/src/indexing.rs"
      provides: "Incremental indexing with comprehensive test coverage"
      exports: ["test_indexer_flush", "test_indexer_pending", "test_indexer_statistics"]
      covered_by: "Task 2"
    - path: "forge_core/src/cache.rs"
      provides: "Query cache with comprehensive test coverage"
      exports: ["test_cache_lru_behavior", "test_cache_concurrent_access", "test_cache_stress"]
      covered_by: "Task 3"
    - path: "forge_core/src/pool.rs"
      provides: "Connection pool with comprehensive test coverage"
      exports: ["test_pool_timeout", "test_pool_concurrent_acquires", "test_pool_stress"]
      covered_by: "Task 4"
    - path: "forge_core/src/runtime.rs"
      provides: "Runtime orchestration with comprehensive test coverage"
      exports: ["test_runtime_full_orchestration", "test_runtime_watch_integration"]
      covered_by: "Task 5"
    - path: "tests/integration/runtime_tests.rs"
      provides: "End-to-end runtime integration tests"
      exports: ["test_runtime_watch_and_index", "test_runtime_cache_invalidation"]
      covered_by: "Task 6"
  key_links:
    - from: "tests/integration/runtime_tests.rs"
      to: "forge_core::runtime::Runtime"
      via: "Forge::with_runtime"
      pattern: "Forge::with_runtime|Runtime::new"
    - from: "forge_core/src/runtime.rs"
      to: "forge_core::watcher"
      via: "Runtime::start_with_watching"
      pattern: "Watcher::new|watcher.start"

---

<objective>
Expand test coverage for all runtime layer components with advanced scenarios and integration tests.

This plan covers the runtime layer in depth:
1. Expand watcher.rs tests with file operations and debouncing
2. Expand indexing.rs tests with flush scenarios and statistics
3. Expand cache.rs tests with LRU behavior and concurrency
4. Expand pool.rs tests with timeout and concurrent access
5. Expand runtime.rs tests with orchestration scenarios
6. Create end-to-end runtime integration tests

Purpose: Runtime layer is critical for production use (hot-reload, caching, pooling). These tests ensure reliable operation under load and edge cases.

Output: 25-30 new tests across runtime modules, integration test file
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-runtime-layer/03-RESEARCH.md
@forge_core/src/watcher.rs
@forge_core/src/indexing.rs
@forge_core/src/cache.rs
@forge_core/src/pool.rs
@forge_core/src/runtime.rs
@tests/common/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand watcher.rs Tests</name>
  <files>forge_core/src/watcher.rs</files>
  <action>
Add 5 new tests to forge_core/src/watcher.rs in #[cfg(test)] mod tests:

1. test_watcher_create_event - Verify WatchEvent::Created is sent when file is created:
   - Create temp directory
   - Create watcher with channel
   - Start watcher
   - Create test file with tokio::fs::write
   - Wait for event via rx.recv() with timeout
   - Verify event is Created with correct path

2. test_watcher_modify_event - Verify WatchEvent::Modified is sent:
   - Create test file
   - Modify file content
   - Verify Modified event received

3. test_watcher_delete_event - Verify WatchEvent::Deleted is sent:
   - Create then delete file
   - Verify Deleted event received

4. test_watcher_recursive_watching - Verify subdirectory events are detected:
   - Create temp/subdir structure
   - Start watcher on parent
   - Create file in subdir
   - Verify event is received

5. test_watcher_multiple_events - Verify multiple events in sequence:
   - Create, then modify, then delete file
   - Verify all three events received in order

Use tokio::time::timeout for event waiting to avoid hanging tests.
  </action>
  <verify>
Run: cargo test -p forge_core watcher
Expected: 8 tests pass (3 existing + 5 new)
  </verify>
  <done>
forge_core/src/watcher.rs has 8 tests covering: basic creation (existing), channel (existing), event equality (existing), file creation, modification, deletion, recursive watching, and multiple event sequences.
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand indexing.rs Tests</name>
  <files>forge_core/src/indexing.rs</files>
  <action>
Add 5 new tests to forge_core/src/indexing.rs in #[cfg(test)] mod tests:

1. test_indexer_flush_multiple - Verify flush processes multiple pending changes:
   - Create indexer
   - Queue 3 different Modified events
   - Call flush()
   - Verify IndexStats shows 3 processed
   - Verify pending is empty after flush

2. test_indexer_delete_handling - Verify deleted files are tracked:
   - Create indexer
   - Queue Deleted event for "removed.rs"
   - Flush and verify deleted_count in stats

3. test_indexer_clear - Verify clear() resets state:
   - Add some pending changes
   - Call clear()
   - Verify pending_changes() returns 0

4. test_indexer_duplicate_queue - Verify duplicate file paths are handled:
   - Queue same file twice
   - Verify only one entry in pending

5. test_indexer_statistics - Verify IndexStats accuracy:
   - Create known mix of Created/Modified/Deleted events
   - Flush and verify all counts match

Use test_forge() or temporary UnifiedGraphStore for testing.
  </action>
  <verify>
Run: cargo test -p forge_core indexing
Expected: 10 tests pass (5 existing + 5 new)
  </verify>
  <done>
forge_core/src/indexing.rs has 10 tests covering: creation (existing), queue (existing), flush (existing), stats (existing), clear (existing), multiple flush, delete handling, clear state, duplicate handling, and statistics accuracy.
  </done>
</task>

<task type="auto">
  <name>Task 3: Expand cache.rs Tests</name>
  <files>forge_core/src/cache.rs</files>
  <action>
Add 5 new tests to forge_core/src/cache.rs in #[cfg(test)] mod tests:

1. test_cache_lru_touch - Verify accessed items move to end (LRU):
   - Create cache with size 3
   - Insert items 1, 2, 3
   - Access item 1 via get()
   - Insert item 4 (causes eviction)
   - Verify item 2 is evicted (oldest, not 1)

2. test_cache_update_existing - Verify updating existing key refreshes TTL:
   - Insert key with value A
   - Wait partial TTL
   - Insert same key with value B
   - Immediately get key - should return B with fresh TTL

3. test_cache_concurrent_access - Verify cache is thread-safe:
   - Spawn 10 tasks concurrently inserting different keys
   - Wait for all to complete
   - Verify all 10 items are in cache

4. test_cache_stress_eviction - Verify FIFO eviction under stress:
   - Create cache with size 5
   - Insert 100 items sequentially
   - Verify only 5 items remain
   - Verify remaining are the last 5 inserted

5. test_cache_zero_max_size - Verify cache with size 0 rejects inserts:
   - Create QueryCache with max_size 0
   - Insert should not add entries
   - Verify len() always returns 0

Use tokio::spawn for concurrent tests.
  </action>
  <verify>
Run: cargo test -p forge_core cache
Expected: 11 tests pass (6 existing + 5 new)
  </verify>
  <done>
forge_core/src/cache.rs has 11 tests covering: insert/get (existing), miss (existing), expiration (existing), eviction (existing), invalidate (existing), clear (existing), LRU touch behavior, key update, concurrent access, stress eviction, and edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 4: Expand pool.rs Tests</name>
  <files>forge_core/src/pool.rs</files>
  <action>
Add 5 new tests to forge_core/src/pool.rs in #[cfg(test)] mod tests:

1. test_pool_concurrent_acquires - Verify multiple tasks can acquire:
   - Create pool with max 5
   - Spawn 10 tasks trying to acquire
   - Use tokio::sync::Barrier to coordinate
   - Verify only 5 acquire at once
   - Verify all 10 complete eventually

2. test_pool_timeout_behavior - Verify acquire times out correctly:
   - Create pool with max 1
   - Acquire 1 permit
   - Try to acquire with timeout using tokio::time::timeout
   - Verify timeout occurs after specified duration

3. test_pool_permit_drop_returns - Verify dropping permit returns to pool:
   - Acquire permit
   - Verify available decreases
   - Drop permit
   - Verify available increases

4. test_pool_stress - Verify pool handles rapid acquire/release cycles:
   - Create pool with max 10
   - Run 100 acquire/release cycles in loop
   - Verify no deadlocks or panics

5. test_pool_all_permits_acquired - Verify pool at capacity:
   - Acquire all permits up to max
   - Verify available_connections() is 0
   - Verify try_acquire returns None
   - Release one and verify try_acquire now works

Use tokio::spawn for concurrent tests and tokio::time::sleep for timing.
  </action>
  <verify>
Run: cargo test -p forge_core pool
Expected: 8 tests pass (3 existing + 5 new)
  </verify>
  <done>
forge_core/src/pool.rs has 8 tests covering: creation (existing), acquire (existing), try_acquire (existing), db_path (existing), concurrent acquires, timeout behavior, permit drop/return, stress testing, and capacity limits.
  </done>
</task>

<task type="auto">
  <name>Task 5: Expand runtime.rs Tests</name>
  <files>forge_core/src/runtime.rs</files>
  <action>
Add 5 new tests to forge_core/src/runtime.rs in #[cfg(test)] mod tests:

1. test_runtime_cache_and_pool_access - Verify runtime exposes cache and pool:
   - Create runtime
   - Call runtime.cache()
   - Call runtime.pool()
   - Verify both return valid instances

2. test_runtime_indexer_integration - Verify indexer gets events:
   - Create runtime with watching
   - Create test file in watched directory
   - Wait for indexer to process (use pending_changes)
   - Verify file appears in indexer queue

3. test_runtime_full_orchestration - Verify all components work together:
   - Create runtime
   - Perform query (uses cache)
   - Create file (triggers watcher)
   - Flush indexer
   - Verify no panics or errors

4. test_runtime_double_start_watching - Verify calling start_watching twice is safe:
   - Start watching once
   - Start watching again (same path)
   - Verify no duplicate watchers or errors

5. test_runtime_stop_watching - Verify stop_watching terminates watcher:
   - Start watching
   - Call stop_watching()
   - Create test file
   - Verify no events received

Use wait_for() helper for async polling conditions.
  </action>
  <verify>
Run: cargo test -p forge_core runtime
Expected: 10 tests pass (5 existing + 5 new)
  </verify>
  <done>
forge_core/src/runtime.rs has 10 tests covering: creation (existing), cache (existing), pending changes (existing), process events (existing), watching (existing), cache/pool access, indexer integration, full orchestration, double start safety, and stop watching behavior.
  </done>
</task>

<task type="auto">
  <name>Task 6: Create Runtime Integration Tests</name>
  <files>tests/integration/runtime_tests.rs</files>
  <action>
Create tests/integration/runtime_tests.rs with end-to-end tests:

```rust
//! End-to-end integration tests for runtime layer.

use forge_core::Forge;
use tests_common::test_forge;

#[tokio::test]
async fn test_runtime_watch_and_index() {
    let temp = tempfile::tempdir().unwrap();

    // Create Forge with runtime
    let forge = Forge::with_runtime(temp.path()).await.unwrap();
    let runtime = forge.runtime().unwrap();

    // Start watching
    runtime.start_watching().await.unwrap();

    // Create a test file
    let test_file = temp.path().join("test.rs");
    tokio::fs::write(&test_file, "fn test() {}").await.unwrap();

    // Wait for indexer to pick it up
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    // Verify indexer has pending change
    let stats = runtime.indexer_stats().await;
    assert!(stats.pending_changes > 0 || stats.total_processed > 0);
}

#[tokio::test]
async fn test_runtime_cache_invalidation() {
    let temp = tempfile::tempdir().unwrap();
    let forge = Forge::with_runtime(temp.path()).await.unwrap();
    let runtime = forge.runtime().unwrap();

    // Insert something in cache
    let cache = runtime.cache();
    cache.insert("test_key".to_string(), "test_value".to_string()).await;

    // Verify it's cached
    assert!(cache.get(&"test_key".to_string()).await.is_some());

    // Invalidate
    cache.invalidate(&"test_key".to_string()).await;

    // Verify it's gone
    assert!(cache.get(&"test_key".to_string()).await.is_none());
}

#[tokio::test]
async fn test_runtime_pool_concurrent_access() {
    let temp = tempfile::tempdir().unwrap();
    let forge = Forge::with_runtime(temp.path()).await.unwrap();
    let runtime = forge.runtime().unwrap();

    let pool = runtime.pool();

    // Try to acquire multiple permits
    let permit1 = pool.acquire().await.unwrap();
    let permit2 = pool.acquire().await.unwrap();

    // Verify we can get at least 2
    assert!(pool.available_connections() < 10);

    drop(permit1);
    drop(permit2);
}
```

Update tests/integration/mod.rs to include:
```rust
mod runtime_tests;
```
  </action>
  <verify>
Run: cargo test --test runtime_tests
Expected: 3 integration tests pass
  </verify>
  <done>
tests/integration/runtime_tests.rs exists with 3 tests: watch_and_index, cache_invalidation, and pool_concurrent_access. All tests use Forge::with_runtime() to test actual runtime behavior.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- [ ] cargo test --workspace passes (all tests)
- [ ] Runtime modules have >80% test coverage
- [ ] Integration tests verify runtime components work together
- [ ] No race conditions in concurrent tests
</verification>

<success_criteria>
Phase 03-03 complete when:
1. All runtime modules have expanded test coverage
2. Runtime integration tests verify end-to-end behavior
3. Concurrency and edge cases are covered
4. cargo test --workspace shows 140+ passing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-test-infrastructure/03-03-SUMMARY.md` with:
- List of tests added per module
- Concurrency test results
- Any race conditions or issues found
</output>
