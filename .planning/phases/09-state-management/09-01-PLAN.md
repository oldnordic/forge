---
phase: 09-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - forge_agent/Cargo.toml
  - forge_agent/src/workflow/mod.rs
  - forge_agent/src/workflow/checkpoint.rs
  - forge_agent/src/workflow/executor.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Workflow state is checkpointed after each step completion"
    - "Checkpoint stores completed_tasks, failed_tasks, current_position"
    - "Checkpoint includes SHA-256 checksum for integrity validation"
    - "Checkpoints stored separately from reasoning debugging checkpoints"
    - "bincode 2.0 serialization for fast state snapshots"
  artifacts:
    - path: "forge_agent/src/workflow/checkpoint.rs"
      provides: "WorkflowCheckpoint, WorkflowCheckpointService"
      min_lines: 300
      exports: ["WorkflowCheckpoint", "WorkflowCheckpointService", "CheckpointId"]
    - path: "forge_agent/src/workflow/executor.rs"
      provides: "Checkpoint integration in executor"
      covered_by: "Task 3"
  key_links:
    - from: "forge_agent/src/workflow/executor.rs"
      to: "forge_agent/src/workflow/checkpoint.rs"
      via: "CheckpointService field in WorkflowExecutor"
      pattern: "checkpoint_service.*save"
    - from: "forge_agent/src/workflow/checkpoint.rs"
      to: "bincode"
      via: "bincode::serialize for state snapshots"
      pattern: "bincode::serialize"
---

# Plan 09-01: State Checkpointing with Forge-Reasoning Integration

**Objective**: Implement workflow state checkpointing after each step completion using bincode serialization and SHA-256 integrity validation.

**Purpose**: Enable workflows to persist execution state incrementally, allowing recovery from failures. Checkpoints store completed tasks, failed tasks, and current position with integrity verification.

**Output**: WorkflowCheckpoint type, WorkflowCheckpointService, executor integration

## Context

@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/09-state-management/09-RESEARCH.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@forge-reasoning/src/checkpoint.rs
@forge-reasoning/src/storage.rs

## Requirements

| ID | Requirement | Status |
|----|-------------|--------|
| WSTA-01 | Workflow state is checkpointed after each step completion | **Implements** |
| WSTA-02 | Failed workflow can resume from last checkpoint instead of restarting | Partial (resumes after 09-02) |

## Integration Points

- **Extend forge-reasoning checkpoint pattern**: Reuse CheckpointStorage trait with separate tables
- **WorkflowExecutor**: Add checkpoint_service field and checkpoint after each task
- **Use existing state module**: Leverage WorkflowState for checkpoint data

## Tasks

### Task 1: Add dependencies and checkpoint module structure

<files>
forge_agent/Cargo.toml, forge_agent/src/workflow/mod.rs, forge_agent/src/workflow/checkpoint.rs
</files>

<action>
1. Add to forge_agent/Cargo.toml dependencies:
   - bincode = "2.0"
   - sha2 = "0.10"

2. Create forge_agent/src/workflow/checkpoint.rs with:
   - WorkflowCheckpoint struct with id, workflow_id, sequence, timestamp, completed_tasks, failed_tasks, current_position, checksum
   - CheckpointId wrapper type (alias to forge_reasoning::CheckpointId)
   - Checkpoint creation from executor state
   - SHA-256 checksum computation and validation

3. Add checkpoint module to workflow/mod.rs:
   - pub mod checkpoint;
   - Re-export WorkflowCheckpoint, WorkflowCheckpointService, CheckpointId

File: forge_agent/Cargo.toml
Add dependencies:
```toml
bincode = "2.0"
sha2 = "0.10"
```

File: forge_agent/src/workflow/checkpoint.rs
Create module with:
- use sha2::{Sha256, Digest};
- use bincode;
- WorkflowCheckpoint struct (derive Clone, Debug, Serialize, Deserialize)
- from_executor() method to capture state
- compute_checksum() internal method
- validate() method for integrity check
</action>

<verify>
cargo check -p forge_agent --all-targets
cargo test -p forge_agent checkpoint:: 2>&1 | head -20
</verify>

<done>
Dependencies added, checkpoint module compiles, WorkflowCheckpoint struct defined with checksum validation
</done>

### Task 2: Implement WorkflowCheckpointService with storage backend

<files>
forge_agent/src/workflow/checkpoint.rs
</files>

<action>
Extend checkpoint.rs with WorkflowCheckpointService:

1. Create WorkflowCheckpointService struct:
   - storage: Arc<dyn CheckpointStorage> (reuse forge_reasoning storage trait)
   - workflow_namespace: "workflow" (separate from "debugging" namespace)

2. Implement service methods:
   - save(checkpoint) -> Result<(), WorkflowError>
   - load(id) -> Result<Option<WorkflowCheckpoint>, WorkflowError>
   - get_latest(workflow_id) -> Result<Option<WorkflowCheckpoint>, WorkflowError>
   - list_by_workflow(workflow_id) -> Result<Vec<CheckpointSummary>, WorkflowError>
   - delete(id) -> Result<(), WorkflowError>

3. Use bincode serialization:
   - bincode::serialize for saving (10x faster than JSON)
   - bincode::deserialize for loading

4. Separate namespace strategy:
   - Prefix checkpoint IDs with "workflow:" to distinguish from debugging checkpoints
   - Store in same SQLiteGraph backend but separate logical namespace

Reference forge_reasoning TemporalCheckpointManager pattern but use bincode instead of JSON.
</action>

<verify>
cargo test -p forge_agent workflow_checkpoint_service 2>&1 | head -30
grep -r "WorkflowCheckpointService" forge_agent/src/
</verify>

<done>
WorkflowCheckpointService implemented with bincode serialization, separate namespace, all CRUD operations working
</done>

### Task 3: Integrate checkpoint service into WorkflowExecutor

<files>
forge_agent/src/workflow/executor.rs
</files>

<action>
Modify WorkflowExecutor to checkpoint after each task:

1. Add field to WorkflowExecutor struct:
   ```rust
   pub(in crate::workflow) checkpoint_service: Option<WorkflowCheckpointService>,
   pub(in crate::workflow) checkpoint_sequence: u64,
   ```

2. Modify execute() method:
   - After each successful task completion, call create_checkpoint()
   - Pass current workflow_id, sequence, position to checkpoint

3. Add create_checkpoint() method:
   - Capture current state: completed_tasks, failed_tasks, current_position
   - Create WorkflowCheckpoint::from_executor()
   - Save via checkpoint_service if available
   - Increment checkpoint_sequence

4. Add with_checkpoint_service() builder method:
   - Allows optional checkpoint service injection
   - Returns executor with checkpointing enabled

5. Handle checkpoint failures gracefully:
   - Log checkpoint failure to audit log
   - Continue execution (checkpoint is best-effort)
   - Don't fail workflow on checkpoint error

Reference existing executor state() method for capturing workflow state.
</action>

<verify>
cargo test -p forge_agent executor::test_checkpoint_after_task 2>&1 | head -30
cargo test -p forge_agent executor 2>&1 | grep -i checkpoint
</verify>

<done>
WorkflowExecutor checkpoints after each task completion, checkpoint service optional via builder, failures logged but don't stop workflow
</done>

## Verification

1. Unit tests for WorkflowCheckpoint creation and validation
2. Integration tests for WorkflowCheckpointService save/load
3. Executor tests verify checkpoint creation after tasks
4. Checksum validation tests detect corruption

## Success Criteria

- [ ] WorkflowCheckpoint stores completed/failed tasks and position
- [ ] SHA-256 checksum validates checkpoint integrity
- [ ] WorkflowCheckpointService uses bincode for serialization
- [ ] WorkflowExecutor creates checkpoint after each successful task
- [ ] Separate namespace from debugging checkpoints
- [ ] cargo check passes, all tests pass

## Output

After completion, create `.planning/phases/09-state-management/09-01-SUMMARY.md`
