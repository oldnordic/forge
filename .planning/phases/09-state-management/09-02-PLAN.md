---
phase: 09-state-management
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - forge_agent/src/workflow/executor.rs
  - forge_agent/src/workflow/checkpoint.rs
  - forge_agent/src/workflow/state.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Failed workflow can resume from last checkpoint instead of restarting"
    - "Resume validates workflow structure matches checkpoint"
    - "Resume skips completed tasks, starts from next position"
    - "Graph drift detection prevents resume with changed workflow"
    - "Checksum validation prevents corrupted checkpoint resume"
  artifacts:
    - path: "forge_agent/src/workflow/executor.rs"
      provides: "resume_from_checkpoint() method"
      covered_by: "Task 3"
    - path: "forge_agent/src/workflow/checkpoint.rs"
      provides: "WorkflowCheckpoint validation helpers"
      exports: ["validate_workflow_consistency"]
  key_links:
    - from: "executor.rs::resume_from_checkpoint"
      to: "checkpoint.rs::WorkflowCheckpoint"
      via: "Load checkpoint, validate checksum, verify workflow structure"
      pattern: "validate.*workflow.*consistency"
    - from: "executor.rs"
      to: "executor.rs::execute"
      via: "Resume uses same execution loop but starts from checkpoint position"
      pattern: "start_position.*checkpoint"

---

# Plan 09-02: Resume After Failure with State Recovery

**Objective**: Implement workflow resumption from last checkpoint, skipping completed tasks and validating workflow consistency.

**Purpose**: Enable failed workflows to continue from where they left off instead of restarting from the beginning, saving time and compute resources.

**Output**: resume_from_checkpoint() method, workflow consistency validation, state restoration

## Context

@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/09-state-management/09-RESEARCH.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/phases/09-state-management/09-01-SUMMARY.md
@forge_agent/src/workflow/executor.rs
@forge_agent/src/workflow/checkpoint.rs
@forge_agent/src/workflow/state.rs

## Requirements

| ID | Requirement | Status |
|----|-------------|--------|
| WSTA-01 | Workflow state is checkpointed after each step completion | From 09-01 |
| WSTA-02 | Failed workflow can resume from last checkpoint instead of restarting | **Implements** |

## Integration Points

- **09-01 WorkflowCheckpoint**: Loads checkpoint to get completed tasks and position
- **WorkflowExecutor execute()**: Resume reuses execution loop with start position
- **state.rs WorkflowState**: Resume updates state with checkpointed data

## Tasks

### Task 1: Implement workflow consistency validation

<files>
forge_agent/src/workflow/checkpoint.rs
</files>

<action>
Add workflow consistency validation to checkpoint module:

1. Add validate_workflow_consistency() function:
   ```rust
   pub fn validate_workflow_consistency(
       workflow: &Workflow,
       checkpoint: &WorkflowCheckpoint,
   ) -> Result<(), WorkflowError>
   ```

2. Validation checks:
   - Task count matches: workflow.task_count() == checkpoint.total_task_count
   - All checkpointed completed_tasks still exist in workflow
   - All checkpointed failed_tasks still exist in workflow
   - Current position is within valid range (0..task_count)

3. Return WorkflowError::WorkflowChanged if validation fails with descriptive message

4. Add graph drift detection (Phase 9 scope - basic):
   - Store task_ids checksum in checkpoint
   - Compare workflow.task_ids() sorted checksum with checkpointed value
   - Fail if mismatch detected

This prevents resuming a workflow that has been modified (tasks added/removed) since checkpoint.
</action>

<verify>
cargo test -p forge_agent test_validate_workflow_consistency 2>&1 | head -30
cargo test -p forge_agent test_graph_drift_detection 2>&1 | head -20
</verify>

<done>
validate_workflow_consistency detects workflow changes, graph drift detection catches task modifications, clear error messages
</done>

### Task 2: Implement state restoration from checkpoint

<files>
forge_agent/src/workflow/executor.rs
</files>

<action>
Add state restoration to WorkflowExecutor:

1. Add restore_state_from_checkpoint() method:
   ```rust
   fn restore_state_from_checkpoint(
       &mut self,
       checkpoint: &WorkflowCheckpoint,
   ) -> Result<(), WorkflowError>
   ```

2. Restoration actions:
   - Clear existing completed_tasks and failed_tasks
   - Restore from checkpoint.completed_tasks and checkpoint.failed_tasks
   - Update checkpoint_sequence to checkpoint.sequence + 1
   - Preserve existing audit_log (do not overwrite)

3. Add restore_checkpoint_state() method:
   - Calls validate_workflow_consistency first
   - Calls restore_state_from_checkpoint if valid
   - Returns error if validation fails

4. State restoration is idempotent:
   - Can be called multiple times safely
   - Clear previous state before restoring

Reference existing state() method structure for state access patterns.
</action>

<verify>
cargo test -p forge_agent test_restore_state_from_checkpoint 2>&1 | head -30
cargo test -p forge_agent test_state_restoration_idempotent 2>&1 | head -20
</verify>

<done>
restore_state_from_checkpoint restores completed/failed tasks, validate before restore, idempotent behavior
</done>

### Task 3: Implement resume_from_checkpoint() execution method

<files>
forge_agent/src/workflow/executor.rs
</files>

<action>
Add resume_from_checkpoint() method to WorkflowExecutor:

1. Method signature:
   ```rust
   pub async fn resume_from_checkpoint(
       &mut self,
       checkpoint_id: &CheckpointId,
   ) -> Result<WorkflowResult, WorkflowError>
   ```

2. Resume logic:
   - Load checkpoint via checkpoint_service.get()
   - Validate checkpoint checksum (checkpoint.validate())
   - Validate workflow consistency (validate_workflow_consistency)
   - Restore state (restore_state_from_checkpoint)
   - Get execution order from workflow
   - Start from checkpoint.current_position + 1
   - Execute remaining tasks using same logic as execute()
   - Continue checkpointing after each task

3. Add resume() convenience method:
   - Finds latest checkpoint for workflow_id
   - Calls resume_from_checkpoint() with latest checkpoint

4. Add can_resume() method:
   - Checks if workflow has valid checkpoint to resume from
   - Returns true if checkpoint exists and workflow is consistent

5. Handle edge cases:
   - No checkpoint found -> return WorkflowError::CheckpointNotFound
   - Checkpoint corrupted -> return WorkflowError::CheckpointCorrupted
   - Workflow changed -> return WorkflowError::WorkflowChanged
   - All tasks completed -> return WorkflowResult::Success immediately

Reuse execute() logic for task execution loop, just with different start position.
</action>

<verify>
cargo test -p forge_agent test_resume_from_checkpoint 2>&1 | head -40
cargo test -p forge_agent test_resume_skip_completed 2>&1 | head -20
cargo test -p forge_agent test_can_resume 2>&1 | head -20
</verify>

<done>
resume_from_checkpoint loads and validates checkpoint, skips completed tasks, executes remaining, all edge cases handled
</done>

## Verification

1. Unit tests for workflow consistency validation
2. Unit tests for state restoration
3. Integration tests for resume with partially completed workflow
4. Tests verify all completed tasks are skipped
5. Tests verify validation failures prevent invalid resume

## Success Criteria

- [ ] resume_from_checkpoint() loads and validates checkpoint
- [ ] Workflow consistency validation detects structure changes
- [ ] Resume skips completed tasks, starts from next position
- [ ] Checksum validation prevents corrupted checkpoint resume
- [ ] can_resume() checks for valid checkpoint
- [ ] All tests pass, cargo check passes

## Output

After completion, create `.planning/phases/09-state-management/09-02-SUMMARY.md`
