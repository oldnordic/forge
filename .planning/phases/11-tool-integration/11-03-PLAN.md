---
phase: 11-tool-integration
plan: 03
type: execute
wave: 3
depends_on: [11-01, 11-02]
files_modified:
  - forge_agent/src/workflow/executor.rs
  - forge_agent/src/workflow/tasks.rs
  - forge_agent/src/workflow/tools.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ToolRegistry is integrated with WorkflowExecutor"
    - "Tool failures trigger fallback handlers"
    - "Fallback handlers can retry or skip failed tools"
    - "Fallback results are logged to audit trail"
    - "Pre-registered tools (magellan, cargo, splice) are available"
  artifacts:
    - path: "forge_agent/src/workflow/tools.rs"
      provides: "FallbackHandler trait and implementations"
      exports: ["FallbackHandler", "RetryFallback", "SkipFallback", "FallbackResult"]
    - path: "forge_agent/src/workflow/executor.rs"
      provides: "ToolRegistry integration and fallback handling"
      contains: "tool_registry"
    - path: "forge_agent/src/workflow/tasks.rs"
      provides: "ToolTask for invoking tools from workflows"
      exports: ["ToolTask"]
  key_links:
    - from: "WorkflowExecutor"
      to: "ToolRegistry"
      via: "tool_registry field for tool invocation"
      pattern: "tool_registry.*invoke"
    - from: "FallbackHandler"
      to: "ToolResult"
      via: "Fn(DeviceResult) -> DeviceResult pattern for error recovery"
      pattern: "fallback.*handle"
    - from: "ToolTask"
      to: "ToolRegistry"
      via: "task delegates tool execution to registry"
      pattern: "ToolTask.*execute"
---

# PLAN 11-03: Fallback Handlers for Tool Failures

## Objective

Implement fallback handlers for tool failures and integrate ToolRegistry with WorkflowExecutor for graceful degradation.

**Purpose:** Enable workflows to recover from tool failures using configurable fallback strategies (retry, skip, custom handlers), with audit logging.

**Output:** Working fallback system with ToolRegistry integration in WorkflowExecutor.

## Execution Context

@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-tool-integration/11-01-PLAN.md
@.planning/phases/11-tool-integration/11-02-PLAN.md
@.planning/phases/09-state-management/09-01-SUMMARY.md

@forge_agent/src/workflow/executor.rs
@forge_agent/src/workflow/tasks.rs
@forge_agent/src/workflow/tools.rs
@forge_agent/src/audit.rs

## Tasks

<task type="auto">
  <name>Task 1: Implement FallbackHandler trait and standard implementations</name>
  <files>forge_agent/src/workflow/tools.rs</files>
  <action>
    Add fallback handler system to tools.rs:

    1. `FallbackResult` enum:
       - `Retry(ToolInvocation)` - retry with same or modified invocation
       - `Skip(TaskResult)` - skip and return result
       - `Fail(ToolError)` - fail with original error

    2. `FallbackHandler` trait:
       ```rust
       #[async_trait]
       pub trait FallbackHandler: Send + Sync {
           async fn handle(&self, error: &ToolError, invocation: &ToolInvocation) -> FallbackResult;
       }
       ```

    3. `RetryFallback` struct:
       - `max_attempts: u32` - maximum retry attempts
       - `backoff_ms: u64` - milliseconds between retries
       - Implements FallbackHandler to retry on transient errors
       - Uses exponential backoff: backoff_ms * 2^attempt

    4. `SkipFallback` struct:
       - `result: TaskResult` - result to return when skipping
       - Implements FallbackHandler to always skip

    5. `ChainFallback` struct:
       - `handlers: Vec<Box<dyn FallbackHandler>>` - chain of handlers
       - Tries each handler in sequence until one returns non-Fail result

    Add unit tests:
    - `test_retry_fallback` - verify retry with backoff
    - `test_skip_fallback` - verify skip returns result
    - `test_chain_fallback` - verify chain tries handlers in sequence

    Reference Phase 08 timeout handling for async timing patterns.

    Note: The pattern is `Fn(ToolError, ToolInvocation) -> FallbackResult` (fix from "DeviceResult" in must_haves).
  </action>
  <verify>cargo test -p forge_agent fallback</verify>
  <done>FallbackHandler trait compiles, all implementations have unit tests</done>
</task>

<task type="auto">
  <name>Task 2: Integrate ToolRegistry into WorkflowExecutor</name>
  <files>forge_agent/src/workflow/executor.rs</files>
  <action>
    Integrate ToolRegistry with WorkflowExecutor:

    1. Add `tool_registry: Option<ToolRegistry>` field to WorkflowExecutor
    2. Add `with_tool_registry(mut self, registry: ToolRegistry) -> Self` builder method
    3. Add `tool_registry(&self) -> Option<&ToolRegistry>` accessor

    4. In `execute()` loop, check if registry is available before task execution
    5. Pass tool_registry reference to TaskContext for task-level access

    Update TaskContext:
    1. Add `tool_registry: Option<ToolRegistry>` field
    2. Add `with_tool_registry(mut self, registry: ToolRegistry) -> Self` builder method
    3. Add `tool_registry(&self) -> Option<&ToolRegistry>` accessor
    4. ToolRegistry must be wrapped in Arc for sharing across contexts

    Add integration test:
    - `test_executor_with_tool_registry` - verify executor can invoke tools via registry

    Reference Phase 09 checkpoint service integration pattern for optional field handling.

    Note: ToolRegistry is Clone, so Arc wrapping may not be strictly necessary but provides consistency with other optional services.
  </action>
  <verify>cargo test -p forge_agent executor_tool_registry</verify>
  <done>WorkflowExecutor has tool_registry field, TaskContext can access it</done>
</task>

<task type="auto">
  <name>Task 3: Implement ToolTask and pre-register standard tools</name>
  <files>forge_agent/src/workflow/tasks.rs</files>
  <action>
    Add ToolTask to tasks.rs:

    1. `ToolTask` struct:
       - `id: TaskId`
       - `name: String`
       - `invocation: ToolInvocation`
       - `fallback: Option<Box<dyn FallbackHandler>>`

    2. Constructor methods:
       - `new(id: TaskId, name: String, tool_name: impl Into<String>) -> Self`
       - `with_args(mut self, args: Vec<String>) -> Self`
       - `with_working_dir(mut self, dir: impl Into<PathBuf>) -> Self`
       - `with_env(mut self, key: impl Into<String>, value: impl Into<String>) -> Self`
       - `with_fallback(mut self, handler: Box<dyn FallbackHandler>) -> Self`

    3. Implement `WorkflowTask` trait:
       - `execute()`: Get tool_registry from context, invoke tool, apply fallback on error
       - `id()`: Return task ID
       - `name()`: Return task name
       - `compensation()`: Return skip compensation (tool side effects handled by ProcessGuard)

    In tools.rs, add `ToolRegistry::with_standard_tools() -> Self`:
    - Pre-register magellan (look up via `which magellan` or use default path)
    - Pre-register cargo (look up via `which cargo`)
    - Pre-register splice (look up via `which splice`)
    - For tools not found, log warning but don't fail (graceful degradation)

    Add `ToolRegistry::default() -> Self` that calls `with_standard_tools()`

    Add unit tests:
    - `test_tool_task_execution` - verify ToolTask invokes tool
    - `test_tool_task_with_fallback` - verify fallback on failure
    - `test_tool_task_compensation` - verify compensation returns skip

    Add integration test:
    - `test_tool_invoke_from_workflow` - verify ToolTask works in real workflow

    Reference ShellCommandTask pattern for WorkflowTask implementation.
  </action>
  <verify>cargo test -p forge_agent tool_task && cargo test -p forge_agent test_tool_invoke_from_workflow</verify>
  <done>ToolTask invokes tools via registry, fallback handles errors</done>
</task>

<task type="auto">
  <name>Task 4: Add audit logging for fallback activations</name>
  <files>forge_agent/src/audit.rs</files>
  <action>
    Add audit events for tool fallback tracking:

    1. Add `WorkflowToolFallback` variant to AuditEvent:
       ```rust
       WorkflowToolFallback {
           timestamp: DateTime<Utc>,
           workflow_id: String,
           task_id: String,
           tool_name: String,
           error: String,
           fallback_action: String,
       }
       ```

    2. In ToolTask::execute(), when fallback is triggered:
       - Record audit event with tool name, error, and fallback action
       - Include whether retry, skip, or fail

    3. Update WorkflowExecutor to log fallback events during execution

    Add unit test:
    - `test_tool_fallback_audit_event` - verify fallback is logged to audit trail

    Reference existing audit event patterns in audit.rs.
  </action>
  <verify>cargo test -p forge_agent audit_tool_fallback</verify>
  <done>Fallback activations are logged to audit trail with context</done>
</task>

</tasks>

<verification>

## Overall Verification

1. **Unit Tests Pass:**
   ```bash
   cargo test -p forge_agent fallback
   cargo test -p forge_agent tool_task
   cargo test -p forge_agent audit_tool_fallback
   ```
   All fallback, tool task, and audit tests pass.

2. **Integration Test:**
   ```bash
   cargo test -p forge_agent test_tool_invoke_from_workflow -- --nocapture
   ```
   Verifies ToolTask works in real workflow with fallback.

3. **Standard Tools Test:**
   ```bash
   cargo test -p forge_agent test_standard_tools -- --nocapture
   ```
   Verifies magellan, cargo, splice are pre-registered.

4. **End-to-End Test:**
   Create workflow with ToolTask that invokes a tool, verify fallback activates on failure.

</verification>

<success_criteria>

1. FallbackHandler trait exists with standard implementations (Retry, Skip, Chain)
2. WorkflowExecutor has tool_registry field and passes to TaskContext
3. ToolTask implements WorkflowTask and invokes tools via registry
4. ToolTask applies fallback handler on tool failure
5. Fallback activations are logged to audit trail
6. ToolRegistry::default() pre-registers magellan, cargo, splice

</success_criteria>

<output>

After completion, create `.planning/phases/11-tool-integration/11-03-SUMMARY.md` with:
- Tasks completed and commits
- Files modified with LOC changes
- Test results (unit + integration)
- Deviations from plan (if any)
- Decisions made
- Phase 11 complete summary (all 3 plans)

</output>
