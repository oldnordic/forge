---
phase: 11-tool-integration
plan: 02
type: execute
wave: 2
depends_on: [11-01]
files_modified:
  - forge_agent/src/workflow/tools.rs
  - forge_agent/src/workflow/mod.rs
  - forge_agent/src/workflow/tasks.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ToolRegistry stores registered tools for lookup by name"
    - "External tools (magellan, cargo, splice) are pre-registered"
    - "Tools can be invoked by name from workflows"
    - "ToolRegistry provides process lifecycle management"
    - "Active tools are tracked and can be queried"
  artifacts:
    - path: "forge_agent/src/workflow/tools.rs"
      provides: "ToolRegistry with HashMap-based tool lookup"
      min_lines: 300
      exports: ["ToolRegistry", "Tool", "ToolInvocation", "ToolResult"]
    - path: "forge_agent/src/workflow/mod.rs"
      provides: "tools module export"
      exports: ["ToolRegistry", "Tool", "ToolInvocation"]
  key_links:
    - from: "ToolRegistry"
      to: "ShellCommandTask"
      via: "tool invocation using tokio::process"
      pattern: "ToolRegistry::invoke"
    - from: "ToolRegistry"
      to: "CompensationRegistry"
      via: "RAII process guards for cleanup"
      pattern: "register_process_spawn"
---

# PLAN 11-02: Tool Registry with RAII Process Guards

## Objective

Implement a ToolRegistry for registering and invoking external tools (magellan, cargo, splice) with RAII-based process lifecycle management.

**Purpose:** Provide a centralized registry for external tools that workflows can invoke by name, with automatic process cleanup via RAII guards.

**Output:** Working ToolRegistry with pre-registered tools and process guard-based cleanup.

## Execution Context

@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-tool-integration/11-01-PLAN.md

@forge_agent/src/workflow/tasks.rs
@forge_agent/src/workflow/rollback.rs
@forge_agent/Cargo.toml

## Tasks

<task type="auto">
  <name>Task 1: Create tools module with Tool and ToolInvocation types</name>
  <files>forge_agent/src/workflow/tools.rs</files>
  <action>
    Create new `tools.rs` module with:

    1. `Tool` struct representing a registered tool:
       - `name: String` - tool identifier (e.g., "magellan", "cargo")
       - `executable: PathBuf` - path to the executable
       - `default_args: Vec<String>` - default arguments
       - `description: String` - human-readable description

    2. `ToolInvocation` struct for a specific invocation:
       - `tool_name: String` - which tool to invoke
       - `args: Vec<String>` - additional arguments beyond defaults
       - `working_dir: Option<PathBuf>` - optional working directory
       - `env: HashMap<String, String>` - optional environment variables

    3. `ToolResult` struct for invocation results:
       - `exit_code: Option<i32>` - process exit code
       - `stdout: String` - captured standard output
       - `stderr: String` - captured standard error
       - `success: bool` - true if exit code was 0

    4. `ToolError` enum:
       - `ToolNotFound(String)` - tool not registered
       - `ExecutionFailed(String)` - process execution failed
       - `Timeout(String)` - tool execution timed out

    Implement `Display` for ToolInvocation (shows full command line).

    Add unit tests for type creation and Display formatting.

    Reference ShellCommandTask from tasks.rs for similar structure.
  </action>
  <verify>cargo check -p forge_agent</verify>
  <done>Tool types compile with all variants and unit tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Implement ToolRegistry with HashMap-based storage</name>
  <files>forge_agent/src/workflow/tools.rs</files>
  <action>
    Implement `ToolRegistry` struct:

    1. Storage: `tools: HashMap<String, Tool>`
    2. `new() -> Self` - creates empty registry

    3. `register(&mut self, tool: Tool) -> Result<(), ToolError>`:
       - Inserts tool into HashMap by name
       - Returns error if tool with same name exists

    4. `get(&self, name: &str) -> Option<&Tool>`:
       - Returns tool by name or None

    5. `invoke(&self, invocation: &ToolInvocation) -> Result<ToolResult, ToolError>`:
       - Look up tool by name
       - Build full command: executable + default_args + invocation.args
       - Use tokio::process::Command for async execution
       - Apply working_dir and env from invocation
       - Wait for output and capture stdout/stderr
       - Return ToolResult with exit code and output

    6. `list_tools(&self) -> Vec<&str>`:
       - Returns names of all registered tools

    7. `is_registered(&self, name: &str) -> bool`:
       - Check if tool exists in registry

    Add unit tests:
    - `test_register_tool` - verify tool registration
    - `test_duplicate_tool` - verify error on duplicate
    - `test_get_tool` - verify lookup
    - `test_list_tools` - verify listing
    - `test_invoke_basic_tool` - verify basic invocation (using "echo" as test tool)

    Derive Clone for Tool and ToolRegistry for test convenience.

    Use tokio::process::async pattern from ShellCommandTask.
  </action>
  <verify>cargo test -p forge_agent tool_registry</verify>
  <done>ToolRegistry stores and retrieves tools, invoke() executes commands</done>
</task>

<task type="auto">
  <name>Task 3: Implement ProcessGuard with RAII cleanup</name>
  <files>forge_agent/src/workflow/tools.rs</files>
  <action>
    Implement `ProcessGuard` struct for RAII-based process lifecycle:

    1. `ProcessGuard` struct:
       - `pid: u32` - process ID being guarded
       - `tool_name: String` - name of tool for logging
       - `terminated: Arc<AtomicBool>` - shared flag to track termination status

    2. `ProcessGuard::new(pid: u32, tool_name: String) -> Self`:
       - Creates guard for spawned process

    3. `impl Drop for ProcessGuard`:
       - On drop, if not terminated, send SIGTERM to process
       - Use `std::process::Command` with "kill" command on Unix
       - Log termination attempt
       - Handle errors gracefully (process may already be dead)

    4. `ProcessGuard::terminate(&self) -> Result<(), ToolError>`:
       - Manually terminate the guarded process
       - Sets terminated flag to prevent double-termination in Drop

    5. `ProcessGuard::pid(&self) -> u32`:
       - Returns the guarded process ID

    6. `ProcessGuard::is_terminated(&self) -> bool`:
       - Returns true if process was terminated

    Update `ToolRegistry::invoke()` to:
       - Spawn process
       - Create ProcessGuard immediately
       - Return ProcessGuard along with ToolResult
       - Use `tokio::time::timeout` for configurable timeout

    Create `ToolInvocationResult` wrapper:
       - `result: ToolResult`
       - `guard: Option<ProcessGuard>` - None for simple commands that complete immediately

    Add unit tests:
    - `test_process_guard_creation` - verify guard creation
    - `test_process_guard_manual_terminate` - verify manual termination
    - `test_process_guard_drop` - verify Drop terminates process (use sleep process for test)

    Add integration with CompensationRegistry:
    - ProcessGuard implements `Into<ToolCompensation>` for automatic rollback registration

    Reference rollback.rs for ToolCompensation pattern.
  </action>
  <verify>cargo test -p forge_agent process_guard</verify>
  <done>ProcessGuard terminates process on drop, tests verify RAII behavior</done>
</task>

</tasks>

<verification>

## Overall Verification

1. **Unit Tests Pass:**
   ```bash
   cargo test -p forge_agent tool
   ```
   All tool registry and process guard tests pass.

2. **Integration Test:**
   ```bash
   cargo test -p forge_agent test_tool_invoke_real -- --nocapture
   ```
   Verifies tool invocation with real commands (echo, ls).

3. **RAII Test:**
   ```bash
   cargo test -p forge_agent test_process_guard_termination
   ```
   Verifies processes are terminated when guard is dropped.

4. **Module Export:**
   Verify tools module is exported from workflow/mod.rs

</verification>

<success_criteria>

1. ToolRegistry stores tools in HashMap for O(1) lookup
2. `register()` adds tools, `get()` retrieves by name
3. `invoke()` executes tools with tokio::process
4. ProcessGuard implements Drop to terminate processes
5. ProcessGuard can be manually terminated via `terminate()`
6. Tools can be converted to ToolCompensation for rollback

</success_criteria>

<output>

After completion, create `.planning/phases/11-tool-integration/11-02-SUMMARY.md` with:
- Tasks completed and commits
- Files modified with LOC changes
- Test results (unit + integration)
- Deviations from plan (if any)
- Decisions made
- Next steps for Plan 11-03

</output>
