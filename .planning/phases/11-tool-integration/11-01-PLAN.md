---
phase: 11-tool-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - forge_agent/src/workflow/tasks.rs
  - forge_agent/src/workflow/task.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ShellCommandTask executes actual shell commands instead of returning Skipped"
    - "Shell commands run with configurable working directory"
    - "Shell commands run with configurable environment variables"
    - "Command stdout and stderr are captured and returned"
    - "Non-zero exit codes return TaskResult::Failed with error message"
    - "Process compensation terminates spawned processes on rollback"
  artifacts:
    - path: "forge_agent/src/workflow/tasks.rs"
      provides: "ShellCommandTask with tokio::process execution"
      min_lines: 150
      contains: "ShellCommandTask"
      exports: ["ShellCommandTask", "ShellCommandConfig"]
    - path: "forge_agent/src/workflow/task.rs"
      provides: "TaskContext extended with working directory support"
      contains: "TaskContext"
  key_links:
    - from: "ShellCommandTask::execute"
      to: "tokio::process::Command"
      via: "spawn() and wait_with_output() for async execution"
      pattern: "tokio::process::Command::new"
    - from: "ShellCommandTask"
      to: "CompensationRegistry"
      via: "process spawn compensation registration"
      pattern: "register_process_spawn"
---

# PLAN 11-01: Shell Command Execution

## Objective

Implement actual shell command execution for `ShellCommandTask` using `tokio::process` with configurable working directory and environment variables.

**Purpose:** Enable workflows to execute external shell commands as tasks, with proper process management and rollback capabilities.

**Output:** Working shell command execution with stdout/stderr capture and process compensation.

## Execution Context

@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-cancellation-timeouts/10-01-SUMMARY.md
@.planning/phases/09-state-management/09-01-SUMMARY.md

@forge_agent/src/workflow/tasks.rs
@forge_agent/src/workflow/task.rs
@forge_agent/src/workflow/rollback.rs

## Tasks

<task type="auto">
  <name>Task 1: Add ShellCommandConfig with working directory and environment support</name>
  <files>forge_agent/src/workflow/tasks.rs</files>
  <action>
    Create a new `ShellCommandConfig` struct in tasks.rs with:
    - `command: String` - the command to execute
    - `args: Vec<String>` - command arguments
    - `working_dir: Option<PathBuf>` - optional working directory
    - `env: HashMap<String, String>` - environment variables to set
    - `timeout: Option<Duration>` - optional timeout for command execution

    Implement builder methods:
    - `new(command: impl Into<String>) -> Self`
    - `args(mut self, args: Vec<String>) -> Self`
    - `working_dir(mut self, path: impl Into<PathBuf>) -> Self`
    - `env(mut self, key: impl Into<String>, value: impl Into<String>) -> Self`
    - `timeout(mut self, duration: Duration) -> Self`

    Derive Clone, Debug, PartialEq.

    Reference existing ShellCommandTask fields for command/args handling.
  </action>
  <verify>cargo check -p forge_agent</verify>
  <done>ShellCommandConfig compiles with builder methods and all fields</done>
</task>

<task type="auto">
  <name>Task 2: Implement ShellCommandTask::execute using tokio::process</name>
  <files>forge_agent/src/workflow/tasks.rs</files>
  <action>
    Replace the stub `execute()` method in ShellCommandTask with actual implementation:

    1. Create `tokio::process::Command` from self.command
    2. Apply args from self.args using `.args()`
    3. Apply working directory from self.config.working_dir using `.current_dir()`
    4. Apply environment variables from self.config.env using `.env()` for each entry
    5. Spawn process using `.spawn()`
    6. Wait for output using `.wait_with_output().await`
    7. Check exit status:
       - `status.success()` -> return `TaskResult::Success`
       - Otherwise -> return `TaskResult::Failed(format!("exit code: {:?}", status.code()))`
    8. Handle IO errors by returning `Err(TaskError::Io(err))`

    Store `child.id()` (process ID) during execution for later compensation.

    Update ShellCommandTask struct to:
    - Store `config: ShellCommandConfig`
    - Store `last_pid: Arc<Mutex<Option<u32>>>` for tracking spawned process
    - Add `with_config()` constructor
    - Keep old `new()` and `with_args()` for backward compatibility (deprecated)

    Reference tokio::process::Command documentation for async pattern.
    Reference Phase 10 timeout handling for optional timeout support.
  </action>
  <verify>cargo check -p forge_agent && cargo test -p forge_agent shell_command</verify>
  <done>ShellCommandTask executes commands, captures output, returns proper TaskResult</done>
</task>

<task type="auto">
  <name>Task 3: Add process compensation to ShellCommandTask</name>
  <files>forge_agent/src/workflow/tasks.rs</files>
  <action>
    Implement `compensation()` method on ShellCommandTask to return process termination:

    1. Check if `self.last_pid` contains a process ID
    2. If Some(pid), return `Some(CompensationAction::undo(...))` with description
    3. If None, return `Some(CompensationAction::skip("No process was spawned"))`

    The undo action should:
    - Read the PID from `self.last_pid.lock().unwrap()`
    - Use the PID to terminate the process
    - Reference `ToolCompensation::process_compensation(pid)` from rollback.rs for the termination logic

    Update the compensation to be an `ExecutableCompensation` with the actual termination logic.

    Add `register_process_spawn()` helper method that integrates with CompensationRegistry:
    - Called after process spawn in execute()
    - Passes PID to registry for automatic rollback

    Add unit tests:
    - `test_shell_command_with_working_dir` - verifies commands run in correct directory
    - `test_shell_command_with_env` - verifies environment variables are passed
    - `test_shell_command_compensation` - verifies process compensation is created

    Reference Phase 09 compensation registry pattern for registration.
  </action>
  <verify>cargo test -p forge_agent shell_command -- --nocapture</verify>
  <done>ShellCommandTask returns process compensation, tests verify termination</done>
</task>

</tasks>

<verification>

## Overall Verification

1. **Unit Tests Pass:**
   ```bash
   cargo test -p forge_agent shell_command
   ```
   All shell command tests pass including working directory, environment, and compensation tests.

2. **Integration Test:**
   ```bash
   cargo test -p forge_agent test_shell_command_execution
   ```
   Verifies actual command execution (e.g., `echo "hello"` produces expected output).

3. **Compensation Test:**
   Verify that spawned processes are tracked and can be terminated during rollback.

4. **Compile Check:**
   ```bash
   cargo check -p forge_agent
   ```
   No warnings, no errors.

</verification>

<success_criteria>

1. `ShellCommandTask::execute()` runs actual shell commands instead of returning `Skipped`
2. Commands execute with configurable working directory via `ShellCommandConfig::working_dir()`
3. Commands execute with configurable environment variables via `ShellCommandConfig::env()`
4. Non-zero exit codes return `TaskResult::Failed` with error message
5. Spawned processes are tracked via PID for compensation
6. `compensation()` method returns process termination compensation

</success_criteria>

<output>

After completion, create `.planning/phases/11-tool-integration/11-01-SUMMARY.md` with:
- Tasks completed and commits
- Files modified with LOC changes
- Test results (unit + integration)
- Deviations from plan (if any)
- Decisions made
- Next steps for Plan 11-02

</output>
