# Plan: Core SDK Implementation

**Phase**: 02 - Core SDK
**Step**: 02-01
**Status**: ðŸ“‹ Planned
**Created**: 2025-12-30

---

## Objective

Implement the forge_core library with actual functionality integrated from Magellan, LLMGrep, Mirage, and Splice.

---

## Overview

This phase integrates the existing tools into a unified SDK API. Each module will wrap the corresponding CLI tool with a programmatic interface.

---

## Module: Storage Abstraction

### File: `forge_core/src/storage/mod.rs`

**Purpose**: Provide a unified interface to SQLiteGraph

```rust
use sqlitegraph::GraphBackend;
use anyhow::Result;

/// Unified graph store for all operations
pub struct UnifiedGraphStore {
    backend: Box<dyn GraphBackend>,
    client: BackendClient,
}

impl UnifiedGraphStore {
    pub async fn open(path: &str) -> Result<Self> {
        // Open SQLiteGraph backend
        // Store both backend and client
    }

    pub fn backend(&self) -> &dyn GraphBackend {
        self.backend.as_ref()
    }

    pub fn client(&self) -> &BackendClient {
        &self.client
    }
}
```

**Tasks:**
- [ ] Define `UnifiedGraphStore` struct
- [ ] Implement `open()` method
- [ ] Implement accessor methods
- [ ] Add error handling

---

## Module: Graph Operations

### File: `forge_core/src/graph/mod.rs`

**Purpose**: Symbol and reference queries via Magellan

```rust
use crate::storage::UnifiedGraphStore;
use crate::types::{Symbol, SymbolId, Location};
use crate::error::Result;

pub struct GraphModule {
    store: Arc<UnifiedGraphStore>,
}

impl GraphModule {
    pub fn find_symbol(&self, name: &str) -> Result<Vec<Symbol>> {
        // Query via Magellan
    }

    pub fn find_symbol_by_id(&self, id: SymbolId) -> Result<Symbol> {
        // Query via Magellan
    }

    pub fn callers_of(&self, symbol: &str) -> Result<Vec<Reference>> {
        // Query via Magellan
    }

    pub fn references(&self, symbol: &str) -> Result<Vec<Reference>> {
        // Query via Magellan
    }

    pub fn reachable_from(&self, id: SymbolId) -> Result<Vec<SymbolId>> {
        // Use Magellan reachable command
    }

    pub fn cycles(&self) -> Result<Vec<Cycle>> {
        // Use Magellan cycles command
    }
}
```

**Integration Points:**
- `magellan query --db <db> --file <path>`
- `magellan find --db <db> --name <name>`
- `magellan refs --db <db> --name <name>`
- `magellan reachable --db <db> --symbol <id>`

**Tasks:**
- [ ] Define `GraphModule` struct
- [ ] Implement `find_symbol()`
- [ ] Implement `find_symbol_by_id()`
- [ ] Implement `callers_of()`
- [ ] Implement `references()`
- [ ] Implement `reachable_from()`
- [ ] Implement `cycles()`
- [ ] Add unit tests

---

## Module: Search Operations

### File: `forge_core/src/search/mod.rs`

**Purpose**: Semantic search via LLMGrep

```rust
use crate::storage::UnifiedGraphStore;
use crate::types::Symbol;
use crate::error::Result;

pub struct SearchModule {
    store: Arc<UnifiedGraphStore>,
}

pub struct SearchBuilder {
    module: SearchModule,
    name_filter: Option<String>,
    kind_filter: Option<SymbolKind>,
    file_filter: Option<String>,
    limit: Option<usize>,
}

impl SearchModule {
    pub fn symbol(&self, name: &str) -> SearchBuilder {
        SearchBuilder {
            module: self.clone(),
            name_filter: Some(name.to_string()),
            kind_filter: None,
            file_filter: None,
            limit: None,
        }
    }

    pub fn pattern(&self, pattern: &str) -> Result<Vec<Symbol>> {
        // Use llmgrep pattern search
    }
}

impl SearchBuilder {
    pub fn kind(mut self, kind: SymbolKind) -> Self {
        self.kind_filter = Some(kind);
        self
    }

    pub fn file(mut self, path: &str) -> Self {
        self.file_filter = Some(path.to_string());
        self
    }

    pub fn limit(mut self, n: usize) -> Self {
        self.limit = Some(n);
        self
    }

    pub fn execute(self) -> Result<Vec<Symbol>> {
        // Execute search via llmgrep
    }
}
```

**Integration Points:**
- `llmgrep --db <db> search --query <name> --output json`

**Tasks:**
- [ ] Define `SearchModule` struct
- [ ] Define `SearchBuilder` struct
- [ ] Implement `symbol()` method
- [ ] Implement `pattern()` method
- [ ] Implement builder methods
- [ ] Add unit tests

---

## Module: CFG Operations

### File: `forge_core/src/cfg/mod.rs`

**Purpose**: CFG analysis via Mirage

```rust
use crate::storage::UnifiedGraphStore;
use crate::types::SymbolId;
use crate::error::Result;

pub struct CfgModule {
    store: Arc<UnifiedGraphStore>,
}

pub struct PathBuilder {
    module: CfgModule,
    function_id: SymbolId,
    normal_only: bool,
    error_only: bool,
    max_length: Option<usize>,
    limit: Option<usize>,
}

pub struct Path {
    pub id: PathId,
    pub kind: PathKind,
    pub blocks: Vec<BlockId>,
    pub length: usize,
}

impl CfgModule {
    pub fn paths(&self, function: SymbolId) -> PathBuilder {
        PathBuilder {
            module: self.clone(),
            function_id: function,
            normal_only: false,
            error_only: false,
            max_length: None,
            limit: None,
        }
    }

    pub fn dominators(&self, function: SymbolId) -> Result<DominatorTree> {
        // Use mirage dominators command
    }

    pub fn loops(&self, function: SymbolId) -> Result<Vec<Loop>> {
        // Use mirage loops command
    }
}
```

**Integration Points:**
- `mirage --db <db> paths --function <symbol>`
- `mirage --db <db> dominators --function <symbol>`
- `mirage --db <db> loops --function <symbol>`

**Tasks:**
- [ ] Define `CfgModule` struct
- [ ] Define `PathBuilder` struct
- [ ] Define `Path` and related types
- [ ] Implement `paths()` method
- [ ] Implement `dominators()` method
- [ ] Implement `loops()` method
- [ ] Add unit tests

---

## Module: Edit Operations

### File: `forge_core/src/edit/mod.rs`

**Purpose**: Span-safe editing via Splice

```rust
use crate::storage::UnifiedGraphStore;
use crate::types::{Symbol, Span};
use crate::error::Result;

pub struct EditModule {
    store: Arc<UnifiedGraphStore>,
}

pub trait EditOperation {
    type Output;
    fn verify(self) -> Result<Self>;
    fn preview(self) -> Result<Diff>;
    fn apply(self) -> Result<Self::Output>;
    fn rollback(self) -> Result<()>;
}

impl EditModule {
    pub fn rename_symbol(&self, old: &str, new: &str) -> RenameOperation {
        RenameOperation {
            module: self.clone(),
            old_name: old.to_string(),
            new_name: new.to_string(),
        }
    }

    pub fn delete_symbol(&self, name: &str) -> DeleteOperation {
        // Create delete operation
    }
}

pub struct RenameOperation {
    module: EditModule,
    old_name: String,
    new_name: String,
    verified: bool,
}

impl EditOperation for RenameOperation {
    type Output = RenameResult;

    fn verify(mut self) -> Result<Self> {
        // Use splice to validate
        self.verified = true;
        Ok(self)
    }

    fn apply(self) -> Result<RenameResult> {
        // Use splice to apply
    }

    fn rollback(self) -> Result<()> {
        // Undo from splice log
    }
}
```

**Integration Points:**
- `splice --db <db> patch --file <path> --symbol <name>`
- `splice --db <db> delete --file <path> --symbol <name>`
- `splice --db <db> undo`

**Tasks:**
- [ ] Define `EditModule` struct
- [ ] Define `EditOperation` trait
- [ ] Implement `rename_symbol()`
- [ ] Implement `delete_symbol()`
- [ ] Implement `RenameOperation`
- [ ] Implement `DeleteOperation`
- [ ] Add unit tests

---

## Module: Analysis

### File: `forge_core/src/analysis/mod.rs`

**Purpose**: Combined operations using multiple modules

```rust
use crate::{GraphModule, CfgModule, EditModule};

pub struct AnalysisModule {
    graph: GraphModule,
    cfg: CfgModule,
    edit: EditModule,
}

impl AnalysisModule {
    pub fn impact_radius(&self, symbol: SymbolId) -> Result<ImpactAnalysis> {
        // Combine graph reach + edit analysis
    }

    pub fn unused_functions(&self, entries: &[SymbolId]) -> Result<Vec<Symbol>> {
        // Combine graph dead code + analysis
    }

    pub fn circular_dependencies(&self) -> Result<Vec<Cycle>> {
        // Use graph cycles
    }
}
```

**Tasks:**
- [ ] Define `AnalysisModule` struct
- [ ] Implement `impact_radius()`
- [ ] Implement `unused_functions()`
- [ ] Implement `circular_dependencies()`
- [ ] Add unit tests

---

## Integration Strategy

### Command Execution

Each module will execute CLI commands and parse JSON output:

```rust
use std::process::Command;

fn execute_magellan(args: &[&str]) -> Result<serde_json::Value> {
    let output = Command::new("magellan")
        .args(args)
        .arg("--output")
        .arg("json")
        .output()?;

    Ok(serde_json::from_slice(&output.stdout)?)
}
```

### Direct Library Integration

Alternatively, link directly to library code (preferred):

```rust
// In Cargo.toml
[dependencies]
magellan = { version = "2.2", default-features = false }
splice = { version = "2.5", default-features = false }

// In code
use magellan::GraphQuery;
use splice::PatchEngine;
```

---

## Success Criteria

- [ ] All modules compile
- [ ] Each module has tests
- [ ] Integration tests pass
- [ ] Examples work
- [ ] API documentation complete

---

*Last updated: 2025-12-30*
