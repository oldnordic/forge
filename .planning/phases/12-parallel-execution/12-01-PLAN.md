---
phase: 12-parallel-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - forge_agent/src/workflow/executor.rs
  - forge_agent/src/workflow/combinators.rs
autonomous: true

must_haves:
  truths:
    - "Independent workflow steps execute in parallel when dependencies allow"
    - "Tasks in same topological layer execute concurrently via JoinSet"
    - "Dependencies between tasks are respected (dependent waits for prerequisite)"
  artifacts:
    - path: "forge_agent/src/workflow/executor.rs"
      provides: "Parallel execution logic in WorkflowExecutor"
      min_lines: 50
      exports: ["execute_parallel", "execution_layers"]
    - path: "forge_agent/src/workflow/combinators.rs"
      provides: "ParallelTasks with actual parallel execution"
      min_lines: 30
      exports: ["ParallelTasks::execute"]
  key_links:
    - from: "executor::execute_parallel"
      to: "tokio::task::JoinSet"
      via: "spawn and join_all pattern"
      pattern: "JoinSet::new|spawn|join_all"
    - from: "executor::execution_layers"
      to: "dag::Workflow"
      via: "topological sort layer computation"
      pattern: "petgraph::algo::toposort"
---

<objective>
Implement fork-join parallelism for independent workflow steps using tokio::task::JoinSet for coordinated task spawning.

Purpose: Enable concurrent execution of tasks that have no dependencies between them, reducing total workflow execution time.

Output: Parallel execution engine that identifies independent tasks and executes them concurrently using JoinSet.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@forge_agent/src/workflow/executor.rs
@forge_agent/src/workflow/dag.rs
@forge_agent/src/workflow/combinators.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add layer computation to Workflow DAG</name>
  <files>forge_agent/src/workflow/dag.rs</files>
  <action>
    Add execution_layers() method to Workflow that groups tasks into topological layers.

    Implementation:
    1. Use petgraph's topological sort to get execution order
    2. Compute longest distance from each node to any root (in-degree = 0)
    3. Group tasks by their distance level (all tasks at level 0 are independent, level 1 depend on level 0, etc.)
    4. Return Vec<Vec<TaskId>> where inner vec contains tasks that can execute in parallel

    Signature:
    ```rust
    pub fn execution_layers(&self) -> Result<Vec<Vec<TaskId>>, WorkflowError>
    ```

    Error handling: Return EmptyWorkflow if no tasks, CycleDetected if graph has cycles.

    Reference: Use the existing execution_order() method as basis, then compute layers by tracking dependency depth.
  </action>
  <verify>
    cargo test -p forge_agent workflow::dag::tests::test_execution_layers
  </verify>
  <done>
    - execution_layers() returns Vec<Vec<TaskId>> with correct layer grouping
    - Tasks in same layer have no dependencies between them
    - Tasks in layer N only depend on tasks in layers < N
    - All tests pass including diamond pattern (a->[b,c]->d produces layers: [[a], [b,c], [d]])
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement parallel execution in WorkflowExecutor</name>
  <files>forge_agent/src/workflow/executor.rs</files>
  <action>
    Add execute_parallel() method that uses tokio::task::JoinSet for concurrent task execution.

    Implementation:
    1. Create new method execute_parallel(&mut self) -> Result<WorkflowResult, WorkflowError>
    2. Get execution layers from workflow.execution_layers()
    3. For each layer: spawn all tasks in layer using JoinSet::spawn()
    4. Wait for all tasks in layer to complete using JoinSet::join_next() in loop
    5. If any task fails, trigger rollback and return error
    6. Move to next layer only after all tasks in current layer complete
    7. Record audit events for parallel task starts/completions

    Signature:
    ```rust
    pub async fn execute_parallel(&mut self) -> Result<WorkflowResult, WorkflowError>
    ```

    Key design decisions:
    - Use JoinSet for coordinated spawning (clearer than manually collecting JoinHandles)
    - Each layer is a fork-join: spawn all tasks, wait for all, then proceed
    - Cancellation token checked between layers (inherited from existing execute())
    - Task timeout applied per-task (inherited from TaskContext)

    Reference: Existing execute() method for audit logging and error handling patterns.
  </action>
  <verify>
    cargo test -p forge_agent workflow::executor::tests::test_execute_parallel
  </verify>
  <done>
    - execute_parallel() spawns tasks in each layer concurrently
    - All tasks in layer N complete before any task in layer N+1 starts
    - Audit events record parallel execution (WorkflowTaskParallelStarted, WorkflowTaskParallelCompleted)
    - Task failures trigger rollback with proper error propagation
    - Cancellation checked between layers
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ParallelTasks combinator to use actual parallel execution</name>
  <files>forge_agent/src/workflow/combinators.rs</files>
  <action>
    Replace sequential execution in ParallelTasks::execute() with parallel execution using tokio::task::JoinSet.

    Implementation:
    1. Change execute() method to use JoinSet instead of for loop
    2. Spawn all tasks concurrently: for task in &self.tasks { set.spawn(task.execute(context)) }
    3. Collect results using while let Some(result) = set.join_next().await
    4. If any task fails, return early with error (fail-fast behavior)
    5. Update doc comment to reflect Phase 12 implementation

    Key design decisions:
    - Clone TaskContext for each spawned task (tasks are Send + Sync)
    - Fail-fast: first error stops execution and returns immediately
    - Consider: Should we collect all errors before returning? For Phase 12, fail-fast is acceptable.

    Reference: tokio::task::JoinSet documentation for spawning and joining pattern.
  </action>
  <verify>
    cargo test -p forge_agent workflow::combinators::tests::test_parallel_tasks_actual_parallel
  </verify>
  <done>
    - ParallelTasks::execute() spawns all tasks concurrently using JoinSet
    - Tasks execute in parallel (verified by timing test: 2 tasks of 100ms each complete in ~100ms total, not ~200ms)
    - Fail-fast behavior: first error stops execution
    - All existing tests still pass (backward compatible)
  </done>
</task>

</tasks>

<verification>
Overall phase verification:

1. **Layer computation correctness**: Test that execution_layers() returns correct groupings for various DAG shapes (linear, diamond, fan-out, fan-in)

2. **Parallel execution performance**: Test that independent tasks complete faster than sequential execution (timing test with delays)

3. **Dependency respect**: Test that dependent tasks never execute concurrently (layer N+1 waits for layer N)

4. **Error handling**: Test that task failure in layer triggers rollback and stops subsequent layers

5. **Audit logging**: Verify audit events capture parallel execution with timestamps
</verification>

<success_criteria>
1. Independent workflow steps execute in parallel when dependencies allow (WOBS-01)

Measured by: Timing test showing 2 independent 100ms tasks complete in ~100ms (not ~200ms), and dependent tasks execute sequentially.
</success_criteria>

<output>
After completion, create `.planning/phases/12-parallel-execution/12-01-SUMMARY.md`
</output>
