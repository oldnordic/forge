---
phase: 12-parallel-execution
plan: 03
type: execute
wave: 3
depends_on: ["12-01", "12-02"]
files_modified:
  - forge_agent/src/workflow/deadlock.rs
  - forge_agent/src/workflow/executor.rs
  - forge_agent/src/workflow/mod.rs
autonomous: true

must_haves:
  truths:
    - "Deadlocks in workflow dependencies are detected before execution"
    - "Resource deadlocks are prevented via timeout-based abort"
    - "Deadlock detection produces actionable error messages"
  artifacts:
    - path: "forge_agent/src/workflow/deadlock.rs"
      provides: "Deadlock detection and prevention"
      min_lines: 100
      exports: ["DeadlockDetector", "DeadlockError", "detect_resource_deadlocks"]
    - path: "forge_agent/src/workflow/executor.rs"
      provides: "Deadlock checking in execute_parallel"
      min_lines: 30
      exports: ["check_for_deadlocks_before_execution"]
  key_links:
    - from: "executor::execute_parallel"
      to: "deadlock::DeadlockDetector"
      via: "pre-execution deadlock check"
      pattern: "detect_deadlocks|check_cycles"
    - from: "deadlock::detect_resource_deadlocks"
      to: "tokio::time::timeout"
      via: "timeout-based deadlock prevention"
      pattern: "timeout|abort"
---

<objective>
Implement deadlock detection and prevention for parallel workflow execution.

Purpose: Prevent workflows from hanging due to dependency cycles or resource contention, ensuring execution always completes or fails explicitly.

Output: Deadlock detector that identifies dependency cycles before execution and timeout-based abort for runtime deadlocks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@forge_agent/src/workflow/dag.rs
@forge_agent/src/workflow/executor.rs
@.planning/phases/12-parallel-execution/12-01-SUMMARY.md
@.planning/phases/12-parallel-execution/12-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deadlock detection module</name>
  <files>forge_agent/src/workflow/deadlock.rs</files>
  <action>
    Create new deadlock.rs module with deadlock detection types and logic.

    Types to define:
    ```rust
    #[derive(Error, Debug)]
    pub enum DeadlockError {
        #[error("Dependency cycle detected: {0:?}")]
        DependencyCycle(Vec<TaskId>),
        #[error("Resource deadlock detected: {0}")]
        ResourceDeadlock(String),
        #[error("Potential deadlock: {0}")]
        PotentialDeadlock(String),
    }

    pub struct DeadlockDetector;

    impl DeadlockDetector {
        /// Detects dependency cycles in the workflow DAG
        pub fn detect_dependency_cycles(workflow: &Workflow) -> Result<(), DeadlockError> {
            // Use petgraph's algo::tarjan_scc or is_cyclic_directed
            // Return detailed cycle path for debugging
        }

        /// Analyzes workflow for potential resource deadlocks
        pub fn detect_resource_deadlocks(workflow: &Workflow) -> Result<Vec<DeadlockWarning>, DeadlockError> {
            // Check for:
            // 1. Tasks that acquire same resources in different orders
            // 2. Long chains of dependent tasks (risk of timeout)
            // 3. Tasks with no timeout (risk of hanging)
        }
    }

    pub struct DeadlockWarning {
        pub task_id: TaskId,
        pub warning_type: DeadlockWarningType,
        pub suggestion: String,
    }

    pub enum DeadlockWarningType {
        SharedResource,
        LongDependencyChain,
        NoTimeout,
    }
    ```

    Implementation notes:
    - Reuse cycle detection from DAG module (WorkflowError::CycleDetected)
    - Resource deadlock analysis is heuristic-based (warn about patterns, don't prevent execution)
    - Dependency cycles must be caught before execution (use existing DAG validation)

    Reference: petgraph::algo for cycle detection algorithms.
  </action>
  <verify>
    cargo test -p forge_agent workflow::deadlock::tests::test_deadlock_detection
  </verify>
  <done>
    - deadlock.rs module compiles and exports DeadlockDetector, DeadlockError
    - detect_dependency_cycles() catches the same cycles as DAG validation
    - detect_resource_deadlocks() produces warnings for risky patterns
    - Unit tests cover: simple cycle, diamond pattern (no cycle), complex cycle, resource sharing warning
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate deadlock detection into executor</name>
  <files>forge_agent/src/workflow/executor.rs</files>
  <action>
    Add pre-execution deadlock check to execute_parallel() and execute().

    Implementation:
    1. At start of execute_parallel(), call DeadlockDetector::detect_dependency_cycles()
    2. If cycle detected, return Error::Deadlock(DeadlockError::DependencyCycle) immediately
    3. Call DeadlockDetector::detect_resource_deadlocks() and log warnings (don't fail)
    4. Add deadlock detection result to audit log (WorkflowDeadlockCheck event)

    New audit event:
    ```rust
    // In audit.rs
    pub enum AuditEvent {
        // ... existing variants
        WorkflowDeadlockCheck {
            timestamp: DateTime<Utc>,
            workflow_id: String,
            has_cycles: bool,
            warnings: Vec<String>,
        },
    }
    ```

    Key design decisions:
    - Deadlock check is fast (O(V + E) graph traversal)
    - Warnings are logged, execution continues (user can decide to risky patterns)
    - Dependency cycles are hard errors (workflow cannot execute)

    Reference: Existing workflow validation in executor.rs.
  </action>
  <verify>
    cargo test -p forge_agent workflow::executor::tests::test_deadlock_check_before_execution
  </verify>
  <done>
    - execute_parallel() checks for deadlocks before spawning any tasks
    - Dependency cycles cause immediate failure with detailed error message
    - Resource deadlock warnings are logged to audit trail
    - WorkflowDeadlockCheck audit event records check results
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement timeout-based deadlock prevention</name>
  <files>forge_agent/src/workflow/deadlock.rs, forge_agent/src/workflow/executor.rs</files>
  <action>
    Add runtime deadlock detection using timeout-based abort.

    Implementation:
    1. Add deadlock_timeout config to WorkflowExecutor (Option<Duration>, default 5 minutes)
    2. Wrap each layer execution in tokio::time::timeout(deadlock_timeout, ...)
    3. If layer times out, abort workflow with DeadlockError::ResourceDeadlock
    4. Add with_deadlock_timeout() builder method to WorkflowExecutor

    Signature:
    ```rust
    impl WorkflowExecutor {
        pub fn with_deadlock_timeout(mut self, timeout: Duration) -> Self {
            self.deadlock_timeout = Some(timeout);
            self
        }
    }
    ```

    Key design decisions:
    - Timeout applies per-layer, not per-task (task timeouts already exist)
    - Default 5 minutes allows for long-running tasks but prevents infinite hangs
    - Timeout can be disabled (None) for workflows that intentionally run long
    - On timeout, cancel all running tasks using CancellationToken

    Reference: Existing timeout handling in Phase 10 (TaskTimeout, WorkflowTimeout).
  </action>
  <verify>
    cargo test -p forge_agent workflow::executor::tests::test_deadlock_timeout_abort
  </verify>
  <done>
    - deadlock_timeout config added to WorkflowExecutor with builder method
    - Layer execution times out after configured duration
    - Timeout triggers cancellation of all tasks in layer
    - DeadlockError::ResourceDeadlock includes timeout duration and layer info
  </done>
</task>

</tasks>

<verification>
Overall phase verification:

1. **Dependency cycle detection**: Test that workflows with dependency cycles fail before execution with clear error message

2. **Resource deadlock warnings**: Test that workflows sharing resources generate warnings but execute successfully

3. **Timeout abort**: Test that stuck workflow (task that never completes) is aborted after deadlock_timeout

4. **Audit logging**: Verify deadlock checks and timeouts are recorded in audit trail

5. **Performance**: Verify deadlock detection doesn't add significant overhead (should be O(V + E) graph traversal)
</verification>

<success_criteria>
1. Deadlocks in workflow dependencies are detected before execution (derived from WOBS-01: independent steps execute in parallel, implying deadlock-free execution)

2. Resource deadlocks are prevented via timeout-based abort (derived from WOBS-01)

Measured by: Cycle detection test and timeout abort test both passing.
</success_criteria>

<output>
After completion, create `.planning/phases/12-parallel-execution/12-03-SUMMARY.md`

This is the final plan of Phase 12 and v0.4 milestone. After completion, the milestone will be ready for audit.
</output>
