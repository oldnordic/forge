---
phase: 12-parallel-execution
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - forge_agent/src/workflow/state.rs
  - forge_agent/src/workflow/executor.rs
autonomous: true

must_haves:
  truths:
    - "Concurrent task execution updates state safely without races"
    - "Multiple tasks can report completion without corrupting workflow state"
    - "State queries return consistent snapshots during parallel execution"
  artifacts:
    - path: "forge_agent/src/workflow/state.rs"
      provides: "Concurrent state management types"
      min_lines: 50
      exports: ["ConcurrentState", "TaskStatus::from_parallel_result"]
    - path: "forge_agent/src/workflow/executor.rs"
      provides: "State updates from parallel execution"
      min_lines: 30
      exports: ["update_state_from_parallel_layer"]
  key_links:
    - from: "executor::execute_parallel"
      to: "state::ConcurrentState"
      via: "thread-safe state updates"
      pattern: "Arc|RwLock|Mutex"
    - from: "state::ConcurrentState"
      to: "tokio::sync"
      via: "async-safe primitives"
      pattern: "RwLock|Mutex"
---

<objective>
Implement concurrent state management for parallel workflow execution using thread-safe collections.

Purpose: Enable multiple tasks to update workflow state concurrently without data races, ensuring consistent state visibility.

Output: Thread-safe state management with Arc<RwLock<T>> or dashmap for concurrent access patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@forge_agent/src/workflow/state.rs
@forge_agent/src/workflow/executor.rs
@.planning/phases/12-parallel-execution/12-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit existing state management for thread-safety</name>
  <files>forge_agent/src/workflow/state.rs, forge_agent/src/workflow/executor.rs</files>
  <action>
    Review current state management in state.rs and executor.rs to identify thread-safety issues:

    1. Check if WorkflowState uses interior mutability (Rc, RefCell) - these are not Send + Sync
    2. Check if TaskStatus enum is safe to share across threads
    3. Identify which state fields are mutated during task execution
    4. Document current state mutation patterns

    Analysis output:
    - List of types that need wrapping for concurrent access
    - Identification of Arc<Mutex<T>> vs Arc<RwLock<T>> requirements
    - Note if dashmap is needed (for concurrent HashMap access) or if standard library suffices

    If WorkflowState is read-only during execution (only executor mutates), use Arc<Mutex<WorkflowState>>.
    If tasks need read access to state, use Arc<RwLock<WorkflowState>> for concurrent reads.

    Reference: Phase 8 state.rs module and executor.rs execute() method.
  </action>
  <verify>
    Document findings in code comments or separate analysis document
  </verify>
  <done>
    - Thread-safety audit complete
    - List of types requiring concurrent access documented
    - Decision on Arc<Mutex<T>> vs Arc<RwLock<T>> vs dashmap documented
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ConcurrentState wrapper</name>
  <files>forge_agent/src/workflow/state.rs</files>
  <action>
    Add ConcurrentState type that wraps WorkflowState with thread-safe access.

    Implementation (choose based on Task 1 analysis):

    Option A - If state mutations are simple and read-heavy:
    ```rust
    use std::sync::{Arc, RwLock};

    pub struct ConcurrentState {
        inner: Arc<RwLock<WorkflowState>>,
    }

    impl ConcurrentState {
        pub fn new(state: WorkflowState) -> Self {
            Self { inner: Arc::new(RwLock::new(state)) }
        }

        pub fn read(&self) -> RwLockReadGuard<WorkflowState> { ... }
        pub fn write(&self) -> RwLockWriteGuard<WorkflowState> { ... }
    }
    ```

    Option B - If state has many concurrent map mutations:
    ```rust
    use dashmap::DashMap;

    pub struct ConcurrentState {
        task_statuses: DashMap<TaskId, TaskStatus>,
        // other fields...
    }
    ```

    Requirements:
    - Implement Clone for ConcurrentState (cheap Arc clone)
    - Provide methods for safe concurrent access (get_task_status, update_task_status, etc.)
    - Ensure Send + Sync bounds

    Reference: tokio::sync and std::sync primitives for async-safe locking.
  </action>
  <verify>
    cargo test -p forge_agent workflow::state::tests::test_concurrent_state_thread_safety
  </verify>
  <done>
    - ConcurrentState type compiles with Send + Sync bounds
    - Clone implementation is cheap (Arc clone only)
    - Read/write access methods prevent data races
    - Unit tests verify concurrent access correctness (use tokio::spawn with barrier)
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate ConcurrentState into parallel execution</name>
  <files>forge_agent/src/workflow/executor.rs</files>
  <action>
    Update execute_parallel() to use ConcurrentState for thread-safe state updates.

    Implementation:
    1. Create ConcurrentState wrapping the workflow state at start of execute_parallel()
    2. Pass Arc<ConcurrentState> to TaskContext for each spawned task
    3. Update state after each task completion using ConcurrentState::write()
    4. Ensure state updates are atomic (no partial updates visible to readers)
    5. Update audit logging to capture state transitions

    Key design decisions:
    - State updates happen after each task completes (not during execution)
    - TaskContext gets Arc<ConcurrentState> for read-only access during execution
    - Executor updates state after joining each task

    Reference: Existing execute() method for state update patterns.
  </action>
  <verify>
    cargo test -p forge_agent workflow::executor::tests::test_parallel_state_updates
  </verify>
  <done>
    - execute_parallel() uses ConcurrentState for all state mutations
    - Concurrent tasks can update state without races (verified with stress test)
    - State snapshots are consistent (no partial updates visible)
    - Audit log records all state transitions with timestamps
  </done>
</task>

</tasks>

<verification>
Overall phase verification:

1. **Thread safety**: Run tests with thread sanitizer (cargo test -- --test-threads=1 is not needed, code should handle multiple threads)

2. **Concurrent stress test**: Spawn 10 tasks concurrently, all updating different parts of state, verify no corruption

3. **State consistency**: Query state during parallel execution, verify no impossible states (e.g., task marked complete before it started)

4. **Performance**: Verify concurrent state access doesn't significantly slow down execution (locks should be uncontended most of the time)
</verification>

<success_criteria>
1. Concurrent task execution updates state safely without races (derived from WOBS-01)

Measured by: Stress test with 10 concurrent tasks showing no data races or state corruption.
</success_criteria>

<output>
After completion, create `.planning/phases/12-parallel-execution/12-02-SUMMARY.md`
</output>
