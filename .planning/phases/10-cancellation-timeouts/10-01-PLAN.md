---
phase: 10-cancellation-timeouts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - forge_agent/Cargo.toml
  - forge_agent/src/workflow/mod.rs
  - forge_agent/src/workflow/cancellation.rs
  - forge_agent/src/workflow/executor.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can cancel running workflow via async cancellation token"
    - "Parent token cancellation propagates to all child tokens"
    - "CancellationToken stored in TaskContext for task access"
    - "Executor checks cancellation status between tasks"
  artifacts:
    - path: "forge_agent/src/workflow/cancellation.rs"
      provides: "CancellationToken, CancellationTokenSource, ChildToken"
      min_lines: 200
      exports: ["CancellationToken", "CancellationTokenSource", "ChildToken"]
    - path: "forge_agent/src/workflow/executor.rs"
      provides: "Cancellation integration in executor"
      min_lines: 950
    - path: "forge_agent/src/workflow/task.rs"
      provides: "CancellationToken in TaskContext"
      min_lines: 460
  key_links:
    - from: "forge_agent/src/workflow/executor.rs"
      to: "forge_agent/src/workflow/cancellation.rs"
      via: "CancellationTokenSource field in WorkflowExecutor"
      pattern: "cancellation_source.*cancel"
    - from: "forge_agent/src/workflow/task.rs"
      to: "forge_agent/src/workflow/cancellation.rs"
      via: "TaskContext.cancellation_token field"
      pattern: "TaskContext.*cancellation"
---

# Plan 10-01: CancellationToken Integration with Parent-Child Hierarchy

## Objective

Create async cancellation token system with parent-child hierarchy for workflow and task-level cancellation propagation.

**Purpose:** Enable users to cancel running workflows and propagate cancellation to all active tasks using a cooperative cancellation model.

**Output:** Working cancellation token system integrated into WorkflowExecutor and TaskContext.

## Execution Context

@~/.claude/get-shit-done/workflows/execute-plan.md

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@forge_agent/src/workflow/executor.rs
@forge_agent/src/workflow/task.rs

## Requirements Mapped

- **WSTA-03:** User can cancel running workflow via async cancellation token
  - Implemented via CancellationTokenSource::cancel() method
  - Propagates through parent-child token hierarchy

## Tasks

<task type="auto">
  <name>Task 1: Create cancellation module with CancellationToken types</name>
  <files>forge_agent/src/workflow/cancellation.rs</files>
  <action>
Create new module forge_agent/src/workflow/cancellation.rs with:

1. CancellationToken struct wrapping Arc<AtomicBool> for thread-safe cancellation state
   - new() creates non-cancelled token
   - is_cancelled() -> bool reads AtomicBool
   - Clone derive for cheap copies

2. CancellationTokenSource struct owning the parent token
   - new() creates source with fresh CancellationToken
   - token() -> CancellationToken returns reference to parent token
   - cancel() sets AtomicBool to true (propagates to all child clones)
   - child_token() -> ChildToken creates derived child token

3. ChildToken struct wrapping parent CancellationToken
   - is_cancelled() checks both parent and local state
   - allows task-level cancellation independent of workflow cancellation

4. Unit tests (minimum 8):
   - test_token_initially_not_cancelled
   - test_source_cancel_sets_token
   - test_token_clone_shares_state
   - test_child_token_inherits_parent_cancellation
   - test_child_token_independent_cancel
   - test_multiple_children_all_cancelled
   - test_cancellation_thread_safe
   - test_token_debug_display

Use tokio_util::sync::CancellationToken as reference pattern, but implement custom to avoid dependency.
  </action>
  <verify>cargo test -p forge_agent workflow::cancellation::tests</verify>
  <done>
CancellationToken, CancellationTokenSource, ChildToken types exist with:
- Thread-safe AtomicBool cancellation state
- Parent-child hierarchy for propagation
- Clone support for sharing across tasks
- All unit tests passing
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cancellation_token field to TaskContext</name>
  <files>forge_agent/src/workflow/task.rs</files>
  <action>
Modify forge_agent/src/workflow/task.rs:

1. Add cancellation_token: Option<CancellationToken> field to TaskContext struct
   - Default to None for backward compatibility

2. Update TaskContext::new() to include cancellation_token parameter
   - Use builder pattern: with_cancellation_token(mut self, token: CancellationToken) -> Self
   - Default implementation sets to None

3. Add pub fn cancellation_token(&self) -> Option<&CancellationToken> accessor

4. Add unit tests (minimum 3):
   - test_context_without_cancellation_token
   - test_context_with_cancellation_token
   - test_context_builder_pattern

5. Update existing tests to use new builder pattern

No changes to CompensationAction or CompensationType needed.
  </action>
  <verify>cargo test -p forge_agent workflow::task::tests::test_context</verify>
  <done>
TaskContext has cancellation_token field with:
- Optional CancellationToken for backward compatibility
- Builder pattern for setting token
- Accessor method for token retrieval
- All existing tests updated and passing
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate cancellation source into WorkflowExecutor</name>
  <files>forge_agent/src/workflow/executor.rs</files>
  <action>
Modify forge_agent/src/workflow/executor.rs:

1. Add cancellation_source: Option<CancellationTokenSource> field to WorkflowExecutor
   - Default to None for backward compatibility

2. Add with_cancellation_source(mut self, source: CancellationTokenSource) -> Self builder method

3. Add pub fn cancellation_token(&self) -> Option<CancellationToken> method
   - Returns token from source if configured, None otherwise

4. Add pub fn cancel(&self) method
   - Calls cancellation_source.cancel() if configured
   - No-op if no cancellation source

5. Modify execute() to check cancellation between tasks:
   - After task execution, check if token.is_cancelled()
   - If cancelled, return WorkflowResult with cancelled status
   - Record WorkflowCancelled event to audit log

6. Add WorkflowCancelled { timestamp, workflow_id } variant to AuditEvent (in audit.rs)
   - Include in workflow module imports

7. Add unit tests (minimum 4):
   - test_executor_without_cancellation_source
   - test_executor_cancellation_token_access
   - test_executor_cancel_stops_execution
   - test_cancellation_recorded_in_audit

8. Modify execute_task() to pass cancellation token to TaskContext:
   - context = TaskContext::new(...).with_cancellation_token(token) if source exists
   - context = TaskContext::new(...) if no source (backward compatible)
  </action>
  <verify>cargo test -p forge_agent workflow::executor::tests</verify>
  <done>
WorkflowExecutor has cancellation integration with:
- Optional CancellationTokenSource field
- Builder pattern for setting source
- cancel() method for triggering cancellation
- Inter-task cancellation checking in execute()
- WorkflowCancelled audit event
- Token passed to TaskContext for tasks
- All tests passing
  </done>
</task>

<task type="auto">
  <name>Task 4: Export cancellation module and add integration tests</name>
  <files>forge_agent/src/workflow/mod.rs</files>
  <action>
Modify forge_agent/src/workflow/mod.rs:

1. Add pub mod cancellation;
2. Add public re-exports: pub use cancellation::{CancellationToken, CancellationTokenSource, ChildToken};

3. Add integration test in cancellation.rs (test module):
   - test_workflow_cancellation_with_executor
   - Creates workflow with 5 sequential tasks
   - Spawns task that calls executor.cancel() after 100ms
   - Verifies execution stops mid-workflow
   - Verifies cancellation recorded in audit log

4. Add dependency to Cargo.toml if needed (verify tokio already present)
  </action>
  <verify>cargo test -p forge_agent workflow::cancellation::tests</verify>
  <done>
Cancellation module exported with:
- Public re-exports in workflow module
- Integration test demonstrating cancellation flow
- All tests passing
  </done>
</task>

</tasks>

## Verification

1. All unit tests pass (20+ tests)
2. Integration test demonstrates mid-workflow cancellation
3. Audit log records WorkflowCancelled event
4. Backward compatibility maintained (cancellation is optional)

## Success Criteria

1. User can cancel running workflow via async cancellation token
2. Parent token cancellation propagates to child tokens
3. CancellationToken accessible via TaskContext
4. Executor checks cancellation between tasks

## Output

After completion, create `.planning/phases/10-cancellation-timeouts/10-01-SUMMARY.md`
